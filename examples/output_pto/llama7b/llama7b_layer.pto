// PTO LLaMA 7B Layer - Dynamic Tiling
// Sequence Length: 16384
// Tile Size: 32x128
// num_full_tiles: 256
// tail_rows: 0

// PTO Module: llama7b_flash
// Generated by PTO ISA Compiler
// Functions: tile_add_64, tile_mul_64, tile_muls_64, tile_exp_64, tile_silu_64, tile_rsqrt_64, tile_matmul_64, tile_rowmax_64, tile_rowsum_64, tile_rowexpandsub_64, tile_rowexpanddiv_64, tile_rowexpandmul_64, tile_add, tile_mul, tile_muls, tile_exp, tile_silu, tile_rsqrt, tile_matmul, tile_rowmax, tile_rowsum, tile_rowexpandsub, tile_rowexpanddiv, tile_rowexpandmul, rmsnorm_tile_64, softmax_tile_64, swiglu_tile_64, linear_tile_64, rope_tile_64, attention_score_tile_64, attention_output_tile_64, residual_add_tile_64, rmsnorm_tile, softmax_tile, swiglu_tile, linear_tile, rope_tile, attention_score_tile, attention_output_tile, residual_add_tile, flash_attn_score_block, flash_attn_softmax_update, flash_attn_output_update, flash_attn_normalize, flash_attn_init_state, llama_layer_dynamic
// Entry: @llama_layer_dynamic

// Function Type: InCore
func @tile_add_64(%input_a: !pto.memref<gm,...,f32>, %input_b: !pto.memref<gm,...,f32>, %output: !pto.memref<gm,...,f32>) {
  // Tile Declarations
  %a = alloc_tile : !pto.tile<64x128xf32>
  %b = alloc_tile : !pto.tile<64x128xf32>
  %result = alloc_tile : !pto.tile<64x128xf32>
  
  // Instructions
  %a = tload %input_a[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<64x128xf32>
  %b = tload %input_b[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<64x128xf32>
  %result = tadd %a, %b : !pto.tile<64x128xf32>
  tstore %result, %output[0, 0]
  
  return
}

// Function Type: InCore
func @tile_mul_64(%input_a: !pto.memref<gm,...,f32>, %input_b: !pto.memref<gm,...,f32>, %output: !pto.memref<gm,...,f32>) {
  // Tile Declarations
  %a = alloc_tile : !pto.tile<64x128xf32>
  %b = alloc_tile : !pto.tile<64x128xf32>
  %result = alloc_tile : !pto.tile<64x128xf32>
  
  // Instructions
  %a = tload %input_a[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<64x128xf32>
  %b = tload %input_b[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<64x128xf32>
  %result = tmul %a, %b : !pto.tile<64x128xf32>
  tstore %result, %output[0, 0]
  
  return
}

// Function Type: InCore
func @tile_muls_64(%input: !pto.memref<gm,...,f32>, %output: !pto.memref<gm,...,f32>) {
  // Tile Declarations
  %a = alloc_tile : !pto.tile<64x128xf32>
  %result = alloc_tile : !pto.tile<64x128xf32>
  
  // Scalar Declarations
  %scale = alloc_scalar : f32
  
  // Instructions
  %a = tload %input[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<64x128xf32>
  %result = tmuls %a, %scale : !pto.tile<64x128xf32>, f32
  tstore %result, %output[0, 0]
  
  return
}

// Function Type: InCore
func @tile_exp_64(%input: !pto.memref<gm,...,f32>, %output: !pto.memref<gm,...,f32>) {
  // Tile Declarations
  %x = alloc_tile : !pto.tile<64x128xf32>
  %result = alloc_tile : !pto.tile<64x128xf32>
  
  // Instructions
  %x = tload %input[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<64x128xf32>
  %result = texp %x : !pto.tile<64x128xf32>
  tstore %result, %output[0, 0]
  
  return
}

// Function Type: InCore
func @tile_silu_64(%input: !pto.memref<gm,...,f32>, %output: !pto.memref<gm,...,f32>) {
  // Tile Declarations
  %x = alloc_tile : !pto.tile<64x128xf32>
  %neg_x = alloc_tile : !pto.tile<64x128xf32>
  %exp_neg_x = alloc_tile : !pto.tile<64x128xf32>
  %one_plus_exp = alloc_tile : !pto.tile<64x128xf32>
  %sigmoid = alloc_tile : !pto.tile<64x128xf32>
  %result = alloc_tile : !pto.tile<64x128xf32>
  
  // Instructions
  %x = tload %input[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<64x128xf32>
  %neg_x = tneg %x : !pto.tile<64x128xf32>
  %exp_neg_x = texp %neg_x : !pto.tile<64x128xf32>
  %one_plus_exp = tadds %exp_neg_x, %1.0 : !pto.tile<64x128xf32>, f32
  %sigmoid = trecip %one_plus_exp : !pto.tile<64x128xf32>
  %result = tmul %x, %sigmoid : !pto.tile<64x128xf32>
  tstore %result, %output[0, 0]
  
  return
}

// Function Type: InCore
func @tile_rsqrt_64(%input: !pto.memref<gm,...,f32>, %output: !pto.memref<gm,...,f32>) {
  // Tile Declarations
  %x = alloc_tile : !pto.tile<64x128xf32>
  %result = alloc_tile : !pto.tile<64x128xf32>
  
  // Instructions
  %x = tload %input[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<64x128xf32>
  %result = trsqrt %x : !pto.tile<64x128xf32>
  tstore %result, %output[0, 0]
  
  return
}

// Function Type: InCore
func @tile_matmul_64(%input_a: !pto.memref<gm,...,f32>, %input_b: !pto.memref<gm,...,f32>, %output: !pto.memref<gm,...,f32>) {
  // Tile Declarations
  %a = alloc_tile : !pto.tile<64x128xf32>
  %b = alloc_tile : !pto.tile<128x128xf32>
  %c = alloc_tile : !pto.tile<64x128xf32>
  
  // Instructions
  %a = tload %input_a[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<64x128xf32>
  %b = tload %input_b[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<128x128xf32>
  %c = tmatmul %a, %b : (!pto.tile<64x128xf32>, !pto.tile<128x128xf32>) -> !pto.tile<64x128xf32>
  tstore %c, %output[0, 0]
  
  return
}

// Function Type: InCore
func @tile_rowmax_64(%input: !pto.memref<gm,...,f32>, %output: !pto.memref<gm,...,f32>) {
  // Tile Declarations
  %x = alloc_tile : !pto.tile<64x128xf32>
  %result = alloc_tile : !pto.tile<64x1xf32>
  
  // Instructions
  %x = tload %input[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<64x128xf32>
  %result = trowmax %x : !pto.tile<64x128xf32> -> !pto.tile<64x1xf32>
  tstore %result, %output[0, 0]
  
  return
}

// Function Type: InCore
func @tile_rowsum_64(%input: !pto.memref<gm,...,f32>, %output: !pto.memref<gm,...,f32>) {
  // Tile Declarations
  %x = alloc_tile : !pto.tile<64x128xf32>
  %result = alloc_tile : !pto.tile<64x1xf32>
  
  // Instructions
  %x = tload %input[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<64x128xf32>
  %result = trowsum %x : !pto.tile<64x128xf32> -> !pto.tile<64x1xf32>
  tstore %result, %output[0, 0]
  
  return
}

// Function Type: InCore
func @tile_rowexpandsub_64(%input_x: !pto.memref<gm,...,f32>, %input_row: !pto.memref<gm,...,f32>, %output: !pto.memref<gm,...,f32>) {
  // Tile Declarations
  %x = alloc_tile : !pto.tile<64x128xf32>
  %row_vals = alloc_tile : !pto.tile<64x1xf32>
  %result = alloc_tile : !pto.tile<64x128xf32>
  
  // Instructions
  %x = tload %input_x[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<64x128xf32>
  %row_vals = tload %input_row[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<64x1xf32>
  %result = trowexpandsub %x, %row_vals : !pto.tile<64x128xf32>, !pto.tile<64x1xf32> -> !pto.tile<64x128xf32>
  tstore %result, %output[0, 0]
  
  return
}

// Function Type: InCore
func @tile_rowexpanddiv_64(%input_x: !pto.memref<gm,...,f32>, %input_row: !pto.memref<gm,...,f32>, %output: !pto.memref<gm,...,f32>) {
  // Tile Declarations
  %x = alloc_tile : !pto.tile<64x128xf32>
  %row_vals = alloc_tile : !pto.tile<64x1xf32>
  %result = alloc_tile : !pto.tile<64x128xf32>
  
  // Instructions
  %x = tload %input_x[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<64x128xf32>
  %row_vals = tload %input_row[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<64x1xf32>
  %result = trowexpanddiv %x, %row_vals : !pto.tile<64x128xf32>, !pto.tile<64x1xf32> -> !pto.tile<64x128xf32>
  tstore %result, %output[0, 0]
  
  return
}

// Function Type: InCore
func @tile_rowexpandmul_64(%input_x: !pto.memref<gm,...,f32>, %input_row: !pto.memref<gm,...,f32>, %output: !pto.memref<gm,...,f32>) {
  // Tile Declarations
  %x = alloc_tile : !pto.tile<64x128xf32>
  %row_vals = alloc_tile : !pto.tile<64x1xf32>
  %result = alloc_tile : !pto.tile<64x128xf32>
  
  // Instructions
  %x = tload %input_x[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<64x128xf32>
  %row_vals = tload %input_row[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<64x1xf32>
  %result = trowexpandmul %x, %row_vals : !pto.tile<64x128xf32>, !pto.tile<64x1xf32> -> !pto.tile<64x128xf32>
  tstore %result, %output[0, 0]
  
  return
}

// Function Type: InCore
func @tile_add(%input_a: !pto.memref<gm,...,f32>, %input_b: !pto.memref<gm,...,f32>, %output: !pto.memref<gm,...,f32>) {
  // Tile Declarations
  %a = alloc_tile : !pto.tile<32x128xf32>
  %b = alloc_tile : !pto.tile<32x128xf32>
  %result = alloc_tile : !pto.tile<32x128xf32>
  
  // Instructions
  %a = tload %input_a[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<32x128xf32>
  %b = tload %input_b[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<32x128xf32>
  %result = tadd %a, %b : !pto.tile<32x128xf32>
  tstore %result, %output[0, 0]
  
  return
}

// Function Type: InCore
func @tile_mul(%input_a: !pto.memref<gm,...,f32>, %input_b: !pto.memref<gm,...,f32>, %output: !pto.memref<gm,...,f32>) {
  // Tile Declarations
  %a = alloc_tile : !pto.tile<32x128xf32>
  %b = alloc_tile : !pto.tile<32x128xf32>
  %result = alloc_tile : !pto.tile<32x128xf32>
  
  // Instructions
  %a = tload %input_a[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<32x128xf32>
  %b = tload %input_b[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<32x128xf32>
  %result = tmul %a, %b : !pto.tile<32x128xf32>
  tstore %result, %output[0, 0]
  
  return
}

// Function Type: InCore
func @tile_muls(%input: !pto.memref<gm,...,f32>, %output: !pto.memref<gm,...,f32>) {
  // Tile Declarations
  %a = alloc_tile : !pto.tile<32x128xf32>
  %result = alloc_tile : !pto.tile<32x128xf32>
  
  // Scalar Declarations
  %scale = alloc_scalar : f32
  
  // Instructions
  %a = tload %input[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<32x128xf32>
  %result = tmuls %a, %scale : !pto.tile<32x128xf32>, f32
  tstore %result, %output[0, 0]
  
  return
}

// Function Type: InCore
func @tile_exp(%input: !pto.memref<gm,...,f32>, %output: !pto.memref<gm,...,f32>) {
  // Tile Declarations
  %x = alloc_tile : !pto.tile<32x128xf32>
  %result = alloc_tile : !pto.tile<32x128xf32>
  
  // Instructions
  %x = tload %input[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<32x128xf32>
  %result = texp %x : !pto.tile<32x128xf32>
  tstore %result, %output[0, 0]
  
  return
}

// Function Type: InCore
func @tile_silu(%input: !pto.memref<gm,...,f32>, %output: !pto.memref<gm,...,f32>) {
  // Tile Declarations
  %x = alloc_tile : !pto.tile<32x128xf32>
  %neg_x = alloc_tile : !pto.tile<32x128xf32>
  %exp_neg_x = alloc_tile : !pto.tile<32x128xf32>
  %one_plus_exp = alloc_tile : !pto.tile<32x128xf32>
  %sigmoid = alloc_tile : !pto.tile<32x128xf32>
  %result = alloc_tile : !pto.tile<32x128xf32>
  
  // Instructions
  %x = tload %input[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<32x128xf32>
  %neg_x = tneg %x : !pto.tile<32x128xf32>
  %exp_neg_x = texp %neg_x : !pto.tile<32x128xf32>
  %one_plus_exp = tadds %exp_neg_x, %1.0 : !pto.tile<32x128xf32>, f32
  %sigmoid = trecip %one_plus_exp : !pto.tile<32x128xf32>
  %result = tmul %x, %sigmoid : !pto.tile<32x128xf32>
  tstore %result, %output[0, 0]
  
  return
}

// Function Type: InCore
func @tile_rsqrt(%input: !pto.memref<gm,...,f32>, %output: !pto.memref<gm,...,f32>) {
  // Tile Declarations
  %x = alloc_tile : !pto.tile<32x128xf32>
  %result = alloc_tile : !pto.tile<32x128xf32>
  
  // Instructions
  %x = tload %input[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<32x128xf32>
  %result = trsqrt %x : !pto.tile<32x128xf32>
  tstore %result, %output[0, 0]
  
  return
}

// Function Type: InCore
func @tile_matmul(%input_a: !pto.memref<gm,...,f32>, %input_b: !pto.memref<gm,...,f32>, %output: !pto.memref<gm,...,f32>) {
  // Tile Declarations
  %a = alloc_tile : !pto.tile<32x128xf32>
  %b = alloc_tile : !pto.tile<128x128xf32>
  %c = alloc_tile : !pto.tile<32x128xf32>
  
  // Instructions
  %a = tload %input_a[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<32x128xf32>
  %b = tload %input_b[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<128x128xf32>
  %c = tmatmul %a, %b : (!pto.tile<32x128xf32>, !pto.tile<128x128xf32>) -> !pto.tile<32x128xf32>
  tstore %c, %output[0, 0]
  
  return
}

// Function Type: InCore
func @tile_rowmax(%input: !pto.memref<gm,...,f32>, %output: !pto.memref<gm,...,f32>) {
  // Tile Declarations
  %x = alloc_tile : !pto.tile<32x128xf32>
  %result = alloc_tile : !pto.tile<32x1xf32>
  
  // Instructions
  %x = tload %input[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<32x128xf32>
  %result = trowmax %x : !pto.tile<32x128xf32> -> !pto.tile<32x1xf32>
  tstore %result, %output[0, 0]
  
  return
}

// Function Type: InCore
func @tile_rowsum(%input: !pto.memref<gm,...,f32>, %output: !pto.memref<gm,...,f32>) {
  // Tile Declarations
  %x = alloc_tile : !pto.tile<32x128xf32>
  %result = alloc_tile : !pto.tile<32x1xf32>
  
  // Instructions
  %x = tload %input[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<32x128xf32>
  %result = trowsum %x : !pto.tile<32x128xf32> -> !pto.tile<32x1xf32>
  tstore %result, %output[0, 0]
  
  return
}

// Function Type: InCore
func @tile_rowexpandsub(%input_x: !pto.memref<gm,...,f32>, %input_row: !pto.memref<gm,...,f32>, %output: !pto.memref<gm,...,f32>) {
  // Tile Declarations
  %x = alloc_tile : !pto.tile<32x128xf32>
  %row_vals = alloc_tile : !pto.tile<32x1xf32>
  %result = alloc_tile : !pto.tile<32x128xf32>
  
  // Instructions
  %x = tload %input_x[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<32x128xf32>
  %row_vals = tload %input_row[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<32x1xf32>
  %result = trowexpandsub %x, %row_vals : !pto.tile<32x128xf32>, !pto.tile<32x1xf32> -> !pto.tile<32x128xf32>
  tstore %result, %output[0, 0]
  
  return
}

// Function Type: InCore
func @tile_rowexpanddiv(%input_x: !pto.memref<gm,...,f32>, %input_row: !pto.memref<gm,...,f32>, %output: !pto.memref<gm,...,f32>) {
  // Tile Declarations
  %x = alloc_tile : !pto.tile<32x128xf32>
  %row_vals = alloc_tile : !pto.tile<32x1xf32>
  %result = alloc_tile : !pto.tile<32x128xf32>
  
  // Instructions
  %x = tload %input_x[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<32x128xf32>
  %row_vals = tload %input_row[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<32x1xf32>
  %result = trowexpanddiv %x, %row_vals : !pto.tile<32x128xf32>, !pto.tile<32x1xf32> -> !pto.tile<32x128xf32>
  tstore %result, %output[0, 0]
  
  return
}

// Function Type: InCore
func @tile_rowexpandmul(%input_x: !pto.memref<gm,...,f32>, %input_row: !pto.memref<gm,...,f32>, %output: !pto.memref<gm,...,f32>) {
  // Tile Declarations
  %x = alloc_tile : !pto.tile<32x128xf32>
  %row_vals = alloc_tile : !pto.tile<32x1xf32>
  %result = alloc_tile : !pto.tile<32x128xf32>
  
  // Instructions
  %x = tload %input_x[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<32x128xf32>
  %row_vals = tload %input_row[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<32x1xf32>
  %result = trowexpandmul %x, %row_vals : !pto.tile<32x128xf32>, !pto.tile<32x1xf32> -> !pto.tile<32x128xf32>
  tstore %result, %output[0, 0]
  
  return
}

// Function Type: InCore
func @rmsnorm_tile_64(%input: !pto.memref<gm,...,f32>, %weights: !pto.memref<gm,...,f32>, %output: !pto.memref<gm,...,f32>) {
  // Tile Declarations
  %x = alloc_tile : !pto.tile<64x128xf32>
  %x_sq = alloc_tile : !pto.tile<64x128xf32>
  %row_sum = alloc_tile : !pto.tile<64x1xf32>
  %row_mean = alloc_tile : !pto.tile<64x1xf32>
  %row_rsqrt = alloc_tile : !pto.tile<64x1xf32>
  %x_norm = alloc_tile : !pto.tile<64x128xf32>
  %gamma = alloc_tile : !pto.tile<64x128xf32>
  %result = alloc_tile : !pto.tile<64x128xf32>
  
  // Scalar Declarations
  %eps = alloc_scalar : f32
  %inv_cols = alloc_scalar : f32
  
  // Instructions
  %x = tload %input[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<64x128xf32>
  %gamma = tload %weights[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<64x128xf32>
  %x_sq = tmul %x, %x : !pto.tile<64x128xf32>
  %row_sum = trowsum %x_sq : !pto.tile<64x128xf32> -> !pto.tile<64x1xf32>
  LI %inv_cols:f32, 0.0078125
  %row_mean = tmuls %row_sum, %inv_cols : !pto.tile<64x1xf32>, f32
  LI %eps:f32, 1e-05
  %row_mean = tadds %row_mean, %eps : !pto.tile<64x1xf32>, f32
  %row_rsqrt = trsqrt %row_mean : !pto.tile<64x1xf32>
  %x_norm = trowexpandmul %x, %row_rsqrt : !pto.tile<64x128xf32>, !pto.tile<64x1xf32> -> !pto.tile<64x128xf32>
  %result = tmul %x_norm, %gamma : !pto.tile<64x128xf32>
  tstore %result, %output[0, 0]
  
  return
}

// Function Type: InCore
func @softmax_tile_64(%input: !pto.memref<gm,...,f32>, %output: !pto.memref<gm,...,f32>) {
  // Tile Declarations
  %x = alloc_tile : !pto.tile<64x128xf32>
  %row_max = alloc_tile : !pto.tile<64x1xf32>
  %x_shifted = alloc_tile : !pto.tile<64x128xf32>
  %exp_x = alloc_tile : !pto.tile<64x128xf32>
  %row_sum = alloc_tile : !pto.tile<64x1xf32>
  %result = alloc_tile : !pto.tile<64x128xf32>
  
  // Instructions
  %x = tload %input[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<64x128xf32>
  %row_max = trowmax %x : !pto.tile<64x128xf32> -> !pto.tile<64x1xf32>
  %x_shifted = trowexpandsub %x, %row_max : !pto.tile<64x128xf32>, !pto.tile<64x1xf32> -> !pto.tile<64x128xf32>
  %exp_x = texp %x_shifted : !pto.tile<64x128xf32>
  %row_sum = trowsum %exp_x : !pto.tile<64x128xf32> -> !pto.tile<64x1xf32>
  %result = trowexpanddiv %exp_x, %row_sum : !pto.tile<64x128xf32>, !pto.tile<64x1xf32> -> !pto.tile<64x128xf32>
  tstore %result, %output[0, 0]
  
  return
}

// Function Type: InCore
func @swiglu_tile_64(%input_gate: !pto.memref<gm,...,f32>, %input_up: !pto.memref<gm,...,f32>, %output: !pto.memref<gm,...,f32>) {
  // Tile Declarations
  %gate = alloc_tile : !pto.tile<64x128xf32>
  %up = alloc_tile : !pto.tile<64x128xf32>
  %neg_gate = alloc_tile : !pto.tile<64x128xf32>
  %exp_neg_gate = alloc_tile : !pto.tile<64x128xf32>
  %one_plus_exp = alloc_tile : !pto.tile<64x128xf32>
  %sigmoid_gate = alloc_tile : !pto.tile<64x128xf32>
  %gate_silu = alloc_tile : !pto.tile<64x128xf32>
  %result = alloc_tile : !pto.tile<64x128xf32>
  
  // Instructions
  %gate = tload %input_gate[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<64x128xf32>
  %up = tload %input_up[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<64x128xf32>
  %neg_gate = tneg %gate : !pto.tile<64x128xf32>
  %exp_neg_gate = texp %neg_gate : !pto.tile<64x128xf32>
  %one_plus_exp = tadds %exp_neg_gate, %1.0 : !pto.tile<64x128xf32>, f32
  %sigmoid_gate = trecip %one_plus_exp : !pto.tile<64x128xf32>
  %gate_silu = tmul %gate, %sigmoid_gate : !pto.tile<64x128xf32>
  %result = tmul %gate_silu, %up : !pto.tile<64x128xf32>
  tstore %result, %output[0, 0]
  
  return
}

// Function Type: InCore
func @linear_tile_64(%input: !pto.memref<gm,...,f32>, %weight: !pto.memref<gm,...,f32>, %output: !pto.memref<gm,...,f32>) {
  // Tile Declarations
  %x = alloc_tile : !pto.tile<64x128xf32>
  %w = alloc_tile : !pto.tile<128x128xf32>
  %result = alloc_tile : !pto.tile<64x128xf32>
  
  // Instructions
  %x = tload %input[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<64x128xf32>
  %w = tload %weight[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<128x128xf32>
  %result = tmatmul %x, %w : (!pto.tile<64x128xf32>, !pto.tile<128x128xf32>) -> !pto.tile<64x128xf32>
  tstore %result, %output[0, 0]
  
  return
}

// Function Type: InCore
func @rope_tile_64(%input: !pto.memref<gm,...,f32>, %cos_cache: !pto.memref<gm,...,f32>, %sin_cache: !pto.memref<gm,...,f32>, %output: !pto.memref<gm,...,f32>) {
  // Tile Declarations
  %x = alloc_tile : !pto.tile<64x128xf32>
  %cos_pos = alloc_tile : !pto.tile<64x128xf32>
  %sin_pos = alloc_tile : !pto.tile<64x128xf32>
  %x_cos = alloc_tile : !pto.tile<64x128xf32>
  %x_sin = alloc_tile : !pto.tile<64x128xf32>
  %result = alloc_tile : !pto.tile<64x128xf32>
  
  // Instructions
  %x = tload %input[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<64x128xf32>
  %cos_pos = tload %cos_cache[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<64x128xf32>
  %sin_pos = tload %sin_cache[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<64x128xf32>
  %x_cos = tmul %x, %cos_pos : !pto.tile<64x128xf32>
  %x_sin = tmul %x, %sin_pos : !pto.tile<64x128xf32>
  %result = tadd %x_cos, %x_sin : !pto.tile<64x128xf32>
  tstore %result, %output[0, 0]
  
  return
}

// Function Type: InCore
func @attention_score_tile_64(%input_q: !pto.memref<gm,...,f32>, %input_kt: !pto.memref<gm,...,f32>, %output: !pto.memref<gm,...,f32>) {
  // Tile Declarations
  %q = alloc_tile : !pto.tile<64x128xf32>
  %k_t = alloc_tile : !pto.tile<128x128xf32>
  %scores = alloc_tile : !pto.tile<64x128xf32>
  %scaled_scores = alloc_tile : !pto.tile<64x128xf32>
  
  // Scalar Declarations
  %scale = alloc_scalar : f32
  
  // Instructions
  %q = tload %input_q[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<64x128xf32>
  %k_t = tload %input_kt[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<128x128xf32>
  %scores = tmatmul %q, %k_t : (!pto.tile<64x128xf32>, !pto.tile<128x128xf32>) -> !pto.tile<64x128xf32>
  LI %scale:f32, 0.08838834764831843
  %scaled_scores = tmuls %scores, %scale : !pto.tile<64x128xf32>, f32
  tstore %scaled_scores, %output[0, 0]
  
  return
}

// Function Type: InCore
func @attention_output_tile_64(%input_weights: !pto.memref<gm,...,f32>, %input_v: !pto.memref<gm,...,f32>, %output: !pto.memref<gm,...,f32>) {
  // Tile Declarations
  %weights = alloc_tile : !pto.tile<64x128xf32>
  %v = alloc_tile : !pto.tile<128x128xf32>
  %result = alloc_tile : !pto.tile<64x128xf32>
  
  // Instructions
  %weights = tload %input_weights[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<64x128xf32>
  %v = tload %input_v[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<128x128xf32>
  %result = tmatmul %weights, %v : (!pto.tile<64x128xf32>, !pto.tile<128x128xf32>) -> !pto.tile<64x128xf32>
  tstore %result, %output[0, 0]
  
  return
}

// Function Type: InCore
func @residual_add_tile_64(%input: !pto.memref<gm,...,f32>, %input_residual: !pto.memref<gm,...,f32>, %output: !pto.memref<gm,...,f32>) {
  // Tile Declarations
  %x = alloc_tile : !pto.tile<64x128xf32>
  %residual = alloc_tile : !pto.tile<64x128xf32>
  %result = alloc_tile : !pto.tile<64x128xf32>
  
  // Instructions
  %x = tload %input[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<64x128xf32>
  %residual = tload %input_residual[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<64x128xf32>
  %result = tadd %x, %residual : !pto.tile<64x128xf32>
  tstore %result, %output[0, 0]
  
  return
}

// Function Type: InCore
func @rmsnorm_tile(%input: !pto.memref<gm,...,f32>, %weights: !pto.memref<gm,...,f32>, %output: !pto.memref<gm,...,f32>) {
  // Tile Declarations
  %x = alloc_tile : !pto.tile<32x128xf32>
  %x_sq = alloc_tile : !pto.tile<32x128xf32>
  %row_sum = alloc_tile : !pto.tile<32x1xf32>
  %row_mean = alloc_tile : !pto.tile<32x1xf32>
  %row_rsqrt = alloc_tile : !pto.tile<32x1xf32>
  %x_norm = alloc_tile : !pto.tile<32x128xf32>
  %gamma = alloc_tile : !pto.tile<32x128xf32>
  %result = alloc_tile : !pto.tile<32x128xf32>
  
  // Scalar Declarations
  %eps = alloc_scalar : f32
  %inv_cols = alloc_scalar : f32
  
  // Instructions
  %x = tload %input[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<32x128xf32>
  %gamma = tload %weights[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<32x128xf32>
  %x_sq = tmul %x, %x : !pto.tile<32x128xf32>
  %row_sum = trowsum %x_sq : !pto.tile<32x128xf32> -> !pto.tile<32x1xf32>
  LI %inv_cols:f32, 0.0078125
  %row_mean = tmuls %row_sum, %inv_cols : !pto.tile<32x1xf32>, f32
  LI %eps:f32, 1e-05
  %row_mean = tadds %row_mean, %eps : !pto.tile<32x1xf32>, f32
  %row_rsqrt = trsqrt %row_mean : !pto.tile<32x1xf32>
  %x_norm = trowexpandmul %x, %row_rsqrt : !pto.tile<32x128xf32>, !pto.tile<32x1xf32> -> !pto.tile<32x128xf32>
  %result = tmul %x_norm, %gamma : !pto.tile<32x128xf32>
  tstore %result, %output[0, 0]
  
  return
}

// Function Type: InCore
func @softmax_tile(%input: !pto.memref<gm,...,f32>, %output: !pto.memref<gm,...,f32>) {
  // Tile Declarations
  %x = alloc_tile : !pto.tile<32x128xf32>
  %row_max = alloc_tile : !pto.tile<32x1xf32>
  %x_shifted = alloc_tile : !pto.tile<32x128xf32>
  %exp_x = alloc_tile : !pto.tile<32x128xf32>
  %row_sum = alloc_tile : !pto.tile<32x1xf32>
  %result = alloc_tile : !pto.tile<32x128xf32>
  
  // Instructions
  %x = tload %input[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<32x128xf32>
  %row_max = trowmax %x : !pto.tile<32x128xf32> -> !pto.tile<32x1xf32>
  %x_shifted = trowexpandsub %x, %row_max : !pto.tile<32x128xf32>, !pto.tile<32x1xf32> -> !pto.tile<32x128xf32>
  %exp_x = texp %x_shifted : !pto.tile<32x128xf32>
  %row_sum = trowsum %exp_x : !pto.tile<32x128xf32> -> !pto.tile<32x1xf32>
  %result = trowexpanddiv %exp_x, %row_sum : !pto.tile<32x128xf32>, !pto.tile<32x1xf32> -> !pto.tile<32x128xf32>
  tstore %result, %output[0, 0]
  
  return
}

// Function Type: InCore
func @swiglu_tile(%input_gate: !pto.memref<gm,...,f32>, %input_up: !pto.memref<gm,...,f32>, %output: !pto.memref<gm,...,f32>) {
  // Tile Declarations
  %gate = alloc_tile : !pto.tile<32x128xf32>
  %up = alloc_tile : !pto.tile<32x128xf32>
  %neg_gate = alloc_tile : !pto.tile<32x128xf32>
  %exp_neg_gate = alloc_tile : !pto.tile<32x128xf32>
  %one_plus_exp = alloc_tile : !pto.tile<32x128xf32>
  %sigmoid_gate = alloc_tile : !pto.tile<32x128xf32>
  %gate_silu = alloc_tile : !pto.tile<32x128xf32>
  %result = alloc_tile : !pto.tile<32x128xf32>
  
  // Instructions
  %gate = tload %input_gate[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<32x128xf32>
  %up = tload %input_up[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<32x128xf32>
  %neg_gate = tneg %gate : !pto.tile<32x128xf32>
  %exp_neg_gate = texp %neg_gate : !pto.tile<32x128xf32>
  %one_plus_exp = tadds %exp_neg_gate, %1.0 : !pto.tile<32x128xf32>, f32
  %sigmoid_gate = trecip %one_plus_exp : !pto.tile<32x128xf32>
  %gate_silu = tmul %gate, %sigmoid_gate : !pto.tile<32x128xf32>
  %result = tmul %gate_silu, %up : !pto.tile<32x128xf32>
  tstore %result, %output[0, 0]
  
  return
}

// Function Type: InCore
func @linear_tile(%input: !pto.memref<gm,...,f32>, %weight: !pto.memref<gm,...,f32>, %output: !pto.memref<gm,...,f32>) {
  // Tile Declarations
  %x = alloc_tile : !pto.tile<32x128xf32>
  %w = alloc_tile : !pto.tile<128x128xf32>
  %result = alloc_tile : !pto.tile<32x128xf32>
  
  // Instructions
  %x = tload %input[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<32x128xf32>
  %w = tload %weight[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<128x128xf32>
  %result = tmatmul %x, %w : (!pto.tile<32x128xf32>, !pto.tile<128x128xf32>) -> !pto.tile<32x128xf32>
  tstore %result, %output[0, 0]
  
  return
}

// Function Type: InCore
func @rope_tile(%input: !pto.memref<gm,...,f32>, %cos_cache: !pto.memref<gm,...,f32>, %sin_cache: !pto.memref<gm,...,f32>, %output: !pto.memref<gm,...,f32>) {
  // Tile Declarations
  %x = alloc_tile : !pto.tile<32x128xf32>
  %cos_pos = alloc_tile : !pto.tile<32x128xf32>
  %sin_pos = alloc_tile : !pto.tile<32x128xf32>
  %x_cos = alloc_tile : !pto.tile<32x128xf32>
  %x_sin = alloc_tile : !pto.tile<32x128xf32>
  %result = alloc_tile : !pto.tile<32x128xf32>
  
  // Instructions
  %x = tload %input[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<32x128xf32>
  %cos_pos = tload %cos_cache[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<32x128xf32>
  %sin_pos = tload %sin_cache[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<32x128xf32>
  %x_cos = tmul %x, %cos_pos : !pto.tile<32x128xf32>
  %x_sin = tmul %x, %sin_pos : !pto.tile<32x128xf32>
  %result = tadd %x_cos, %x_sin : !pto.tile<32x128xf32>
  tstore %result, %output[0, 0]
  
  return
}

// Function Type: InCore
func @attention_score_tile(%input_q: !pto.memref<gm,...,f32>, %input_kt: !pto.memref<gm,...,f32>, %output: !pto.memref<gm,...,f32>) {
  // Tile Declarations
  %q = alloc_tile : !pto.tile<32x128xf32>
  %k_t = alloc_tile : !pto.tile<128x128xf32>
  %scores = alloc_tile : !pto.tile<32x128xf32>
  %scaled_scores = alloc_tile : !pto.tile<32x128xf32>
  
  // Scalar Declarations
  %scale = alloc_scalar : f32
  
  // Instructions
  %q = tload %input_q[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<32x128xf32>
  %k_t = tload %input_kt[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<128x128xf32>
  %scores = tmatmul %q, %k_t : (!pto.tile<32x128xf32>, !pto.tile<128x128xf32>) -> !pto.tile<32x128xf32>
  LI %scale:f32, 0.08838834764831843
  %scaled_scores = tmuls %scores, %scale : !pto.tile<32x128xf32>, f32
  tstore %scaled_scores, %output[0, 0]
  
  return
}

// Function Type: InCore
func @attention_output_tile(%input_weights: !pto.memref<gm,...,f32>, %input_v: !pto.memref<gm,...,f32>, %output: !pto.memref<gm,...,f32>) {
  // Tile Declarations
  %weights = alloc_tile : !pto.tile<32x128xf32>
  %v = alloc_tile : !pto.tile<128x128xf32>
  %result = alloc_tile : !pto.tile<32x128xf32>
  
  // Instructions
  %weights = tload %input_weights[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<32x128xf32>
  %v = tload %input_v[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<128x128xf32>
  %result = tmatmul %weights, %v : (!pto.tile<32x128xf32>, !pto.tile<128x128xf32>) -> !pto.tile<32x128xf32>
  tstore %result, %output[0, 0]
  
  return
}

// Function Type: InCore
func @residual_add_tile(%input: !pto.memref<gm,...,f32>, %input_residual: !pto.memref<gm,...,f32>, %output: !pto.memref<gm,...,f32>) {
  // Tile Declarations
  %x = alloc_tile : !pto.tile<32x128xf32>
  %residual = alloc_tile : !pto.tile<32x128xf32>
  %result = alloc_tile : !pto.tile<32x128xf32>
  
  // Instructions
  %x = tload %input[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<32x128xf32>
  %residual = tload %input_residual[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<32x128xf32>
  %result = tadd %x, %residual : !pto.tile<32x128xf32>
  tstore %result, %output[0, 0]
  
  return
}

// Function Type: InCore
func @flash_attn_score_block(%input_q: !pto.memref<gm,...,f32>, %input_k: !pto.memref<gm,...,f32>, %output_s: !pto.memref<gm,...,f32>) {
  // Tile Declarations
  %q_block = alloc_tile : !pto.tile<64x128xf32>
  %k_block = alloc_tile : !pto.tile<64x128xf32>
  %s_block = alloc_tile : !pto.tile<64x64xf32>
  %s_scaled = alloc_tile : !pto.tile<64x64xf32>
  
  // Scalar Declarations
  %scale = alloc_scalar : f32
  
  // Instructions
  %q_block = tload %input_q[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<64x128xf32>
  %k_block = tload %input_k[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<64x128xf32>
  %s_block = tmatmul %q_block, %k_block : (!pto.tile<64x128xf32>, !pto.tile<64x128xf32>) -> !pto.tile<64x64xf32>
  LI %scale:f32, 0.08838834764831843
  %s_scaled = tmuls %s_block, %scale : !pto.tile<64x64xf32>, f32
  tstore %s_scaled, %output_s[0, 0]
  
  return
}

// Function Type: InCore
func @flash_attn_softmax_update(%input_s: !pto.memref<gm,...,f32>, %input_m_prev: !pto.memref<gm,...,f32>, %input_l_prev: !pto.memref<gm,...,f32>, %output_m_new: !pto.memref<gm,...,f32>, %output_l_new: !pto.memref<gm,...,f32>, %output_p: !pto.memref<gm,...,f32>, %output_scale_old: !pto.memref<gm,...,f32>) {
  // Tile Declarations
  %s_block = alloc_tile : !pto.tile<64x64xf32>
  %m_prev = alloc_tile : !pto.tile<64x1xf32>
  %l_prev = alloc_tile : !pto.tile<64x1xf32>
  %m_new = alloc_tile : !pto.tile<64x1xf32>
  %m_cur = alloc_tile : !pto.tile<64x1xf32>
  %l_new = alloc_tile : !pto.tile<64x1xf32>
  %p_block = alloc_tile : !pto.tile<64x64xf32>
  %s_shifted = alloc_tile : !pto.tile<64x64xf32>
  %scale_old = alloc_tile : !pto.tile<64x1xf32>
  %m_diff = alloc_tile : !pto.tile<64x1xf32>
  %l_scaled = alloc_tile : !pto.tile<64x1xf32>
  %p_rowsum = alloc_tile : !pto.tile<64x1xf32>
  
  // Instructions
  %s_block = tload %input_s[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<64x64xf32>
  %m_prev = tload %input_m_prev[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<64x1xf32>
  %l_prev = tload %input_l_prev[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<64x1xf32>
  %m_cur = trowmax %s_block : !pto.tile<64x64xf32> -> !pto.tile<64x1xf32>
  %m_new = tmax %m_prev, %m_cur : !pto.tile<64x1xf32>
  %s_shifted = trowexpandsub %s_block, %m_new : !pto.tile<64x64xf32>, !pto.tile<64x1xf32> -> !pto.tile<64x64xf32>
  %p_block = texp %s_shifted : !pto.tile<64x64xf32>
  %m_diff = tsub %m_prev, %m_new : !pto.tile<64x1xf32>
  %scale_old = texp %m_diff : !pto.tile<64x1xf32>
  %l_scaled = tmul %scale_old, %l_prev : !pto.tile<64x1xf32>
  %p_rowsum = trowsum %p_block : !pto.tile<64x64xf32> -> !pto.tile<64x1xf32>
  %l_new = tadd %l_scaled, %p_rowsum : !pto.tile<64x1xf32>
  tstore %m_new, %output_m_new[0, 0]
  tstore %l_new, %output_l_new[0, 0]
  tstore %p_block, %output_p[0, 0]
  tstore %scale_old, %output_scale_old[0, 0]
  
  return
}

// Function Type: InCore
func @flash_attn_output_update(%input_o_prev: !pto.memref<gm,...,f32>, %input_p: !pto.memref<gm,...,f32>, %input_v: !pto.memref<gm,...,f32>, %input_scale: !pto.memref<gm,...,f32>, %output_o: !pto.memref<gm,...,f32>) {
  // Tile Declarations
  %o_prev = alloc_tile : !pto.tile<64x128xf32>
  %p_block = alloc_tile : !pto.tile<64x64xf32>
  %v_block = alloc_tile : !pto.tile<64x128xf32>
  %scale_old = alloc_tile : !pto.tile<64x1xf32>
  %o_scaled = alloc_tile : !pto.tile<64x128xf32>
  %pv = alloc_tile : !pto.tile<64x128xf32>
  %o_new = alloc_tile : !pto.tile<64x128xf32>
  
  // Instructions
  %o_prev = tload %input_o_prev[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<64x128xf32>
  %p_block = tload %input_p[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<64x64xf32>
  %v_block = tload %input_v[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<64x128xf32>
  %scale_old = tload %input_scale[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<64x1xf32>
  %o_scaled = trowexpandmul %o_prev, %scale_old : !pto.tile<64x128xf32>, !pto.tile<64x1xf32> -> !pto.tile<64x128xf32>
  %pv = tmatmul %p_block, %v_block : (!pto.tile<64x64xf32>, !pto.tile<64x128xf32>) -> !pto.tile<64x128xf32>
  %o_new = tadd %o_scaled, %pv : !pto.tile<64x128xf32>
  tstore %o_new, %output_o[0, 0]
  
  return
}

// Function Type: InCore
func @flash_attn_normalize(%input_o: !pto.memref<gm,...,f32>, %input_l: !pto.memref<gm,...,f32>, %output: !pto.memref<gm,...,f32>) {
  // Tile Declarations
  %o_block = alloc_tile : !pto.tile<64x128xf32>
  %l_vec = alloc_tile : !pto.tile<64x1xf32>
  %o_final = alloc_tile : !pto.tile<64x128xf32>
  
  // Instructions
  %o_block = tload %input_o[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<64x128xf32>
  %l_vec = tload %input_l[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<64x1xf32>
  %o_final = trowexpanddiv %o_block, %l_vec : !pto.tile<64x128xf32>, !pto.tile<64x1xf32> -> !pto.tile<64x128xf32>
  tstore %o_final, %output[0, 0]
  
  return
}

// Function Type: InCore
func @flash_attn_init_state(%input_zeros_large: !pto.memref<gm,...,f32>, %input_zeros_small: !pto.memref<gm,...,f32>, %input_neg_inf: !pto.memref<gm,...,f32>, %output_o: !pto.memref<gm,...,f32>, %output_l: !pto.memref<gm,...,f32>, %output_m: !pto.memref<gm,...,f32>) {
  // Tile Declarations
  %o_init = alloc_tile : !pto.tile<64x128xf32>
  %l_init = alloc_tile : !pto.tile<64x1xf32>
  %m_init = alloc_tile : !pto.tile<64x1xf32>
  
  // Instructions
  %o_init = tload %input_zeros_large[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<64x128xf32>
  %l_init = tload %input_zeros_small[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<64x1xf32>
  %m_init = tload %input_neg_inf[0, 0] : (!pto.memref<gm,...,f32>, index, index) -> !pto.tile<64x1xf32>
  tstore %o_init, %output_o[0, 0]
  tstore %l_init, %output_l[0, 0]
  tstore %m_init, %output_m[0, 0]
  
  return
}

// Function Type: Orchestration
func @llama_layer_dynamic(%input: !pto.memref<gm,...,f32>, %output: !pto.memref<gm,...,f32>, %attn_norm_weights: !pto.memref<gm,...,f32>, %wq: !pto.memref<gm,...,f32>, %wk: !pto.memref<gm,...,f32>, %wv: !pto.memref<gm,...,f32>, %wo: !pto.memref<gm,...,f32>, %cos_cache: !pto.memref<gm,...,f32>, %sin_cache: !pto.memref<gm,...,f32>, %mlp_norm_weights: !pto.memref<gm,...,f32>, %w_gate: !pto.memref<gm,...,f32>, %w_up: !pto.memref<gm,...,f32>, %w_down: !pto.memref<gm,...,f32>, %all_q_tiles: !pto.memref<gm,...,f32>, %all_k_tiles: !pto.memref<gm,...,f32>, %all_v_tiles: !pto.memref<gm,...,f32>, %all_q_rope: !pto.memref<gm,...,f32>, %all_k_rope: !pto.memref<gm,...,f32>, %all_attn_out: !pto.memref<gm,...,f32>, %all_m_vec: !pto.memref<gm,...,f32>, %all_l_vec: !pto.memref<gm,...,f32>, %all_hidden: !pto.memref<gm,...,f32>, %temp_norm: !pto.memref<gm,...,f32>, %temp_scores: !pto.memref<gm,...,f32>, %temp_attn_weights: !pto.memref<gm,...,f32>, %temp_scale: !pto.memref<gm,...,f32>, %temp_gate: !pto.memref<gm,...,f32>, %temp_up: !pto.memref<gm,...,f32>, %temp_swiglu: !pto.memref<gm,...,f32>, %temp_mlp_out: !pto.memref<gm,...,f32>, %const_zeros_large: !pto.memref<gm,...,f32>, %const_zeros_small: !pto.memref<gm,...,f32>, %const_neg_inf: !pto.memref<gm,...,f32>) {
  // Tile Declarations
  
  // Scalar Declarations
  %seq_len = alloc_scalar : i32
  %tile_rows = alloc_scalar : i32
  %num_tiles = alloc_scalar : i32
  %zero = alloc_scalar : i32
  
  // Instructions
  LI %tile_rows:i32, 32
  LI %zero:i32, 0
  FOR %tile_i:idx, 0:idx, %num_tiles:idx, 1:idx max_range=2048 min_range=256 tile_levels={4096:64,2048:64,1024:64,512:64,256:64}
    CALL @rmsnorm_tile(%input -> (%input, tile_i, 0), %weights -> %attn_norm_weights, %output -> (%temp_norm, tile_i, 0))
    CALL @tile_matmul(%input_a -> (%temp_norm, tile_i, 0), %input_b -> %wq, %output -> (%all_q_tiles, tile_i, 0))
    CALL @tile_matmul(%input_a -> (%temp_norm, tile_i, 0), %input_b -> %wk, %output -> (%all_k_tiles, tile_i, 0))
    CALL @tile_matmul(%input_a -> (%temp_norm, tile_i, 0), %input_b -> %wv, %output -> (%all_v_tiles, tile_i, 0))
    CALL @rope_tile(%input -> (%all_q_tiles, tile_i, 0), %cos_cache -> %cos_cache, %sin_cache -> %sin_cache, %output -> (%all_q_rope, tile_i, 0))
    CALL @rope_tile(%input -> (%all_k_tiles, tile_i, 0), %cos_cache -> %cos_cache, %sin_cache -> %sin_cache, %output -> (%all_k_rope, tile_i, 0))
  ENDFOR
  FOR %q_tile:idx, 0:idx, %num_tiles:idx, 1:idx max_range=2048 min_range=256 tile_levels={4096:64,2048:64,1024:64,512:64,256:64}
    CALL @flash_attn_init_state(%input_zeros_large -> %const_zeros_large, %input_zeros_small -> %const_zeros_small, %input_neg_inf -> %const_neg_inf, %output_o -> (%all_attn_out, q_tile, 0), %output_l -> (%all_l_vec, q_tile, 0), %output_m -> (%all_m_vec, q_tile, 0))
    FOR %kv_tile:idx, 0:idx, %num_tiles:idx, 1:idx max_range=2048 min_range=256 tile_levels={4096:64,2048:64,1024:64,512:64,256:64}
      CALL @flash_attn_score_block(%input_q -> (%all_q_rope, q_tile, 0), %input_k -> (%all_k_rope, kv_tile, 0), %output_s -> (%temp_scores, q_tile, 0))
      CALL @flash_attn_softmax_update(%input_s -> (%temp_scores, q_tile, 0), %input_m_prev -> (%all_m_vec, q_tile, 0), %input_l_prev -> (%all_l_vec, q_tile, 0), %output_m_new -> (%all_m_vec, q_tile, 0), %output_l_new -> (%all_l_vec, q_tile, 0), %output_p -> (%temp_attn_weights, q_tile, 0), %output_scale_old -> (%temp_scale, q_tile, 0))
      CALL @flash_attn_output_update(%input_o_prev -> (%all_attn_out, q_tile, 0), %input_p -> (%temp_attn_weights, q_tile, 0), %input_v -> (%all_v_tiles, kv_tile, 0), %input_scale -> (%temp_scale, q_tile, 0), %output_o -> (%all_attn_out, q_tile, 0))
    ENDFOR
    CALL @flash_attn_normalize(%input_o -> (%all_attn_out, q_tile, 0), %input_l -> (%all_l_vec, q_tile, 0), %output -> (%all_attn_out, q_tile, 0))
  ENDFOR
  FOR %tile_i:idx, 0:idx, %num_tiles:idx, 1:idx max_range=2048 min_range=256 tile_levels={4096:64,2048:64,1024:64,512:64,256:64}
    CALL @tile_matmul(%input_a -> (%all_attn_out, tile_i, 0), %input_b -> %wo, %output -> (%temp_norm, tile_i, 0))
    CALL @residual_add_tile(%input -> (%temp_norm, tile_i, 0), %input_residual -> (%input, tile_i, 0), %output -> (%all_hidden, tile_i, 0))
    CALL @rmsnorm_tile(%input -> (%all_hidden, tile_i, 0), %weights -> %mlp_norm_weights, %output -> (%temp_norm, tile_i, 0))
    CALL @tile_matmul(%input_a -> (%temp_norm, tile_i, 0), %input_b -> %w_gate, %output -> (%temp_gate, tile_i, 0))
    CALL @tile_matmul(%input_a -> (%temp_norm, tile_i, 0), %input_b -> %w_up, %output -> (%temp_up, tile_i, 0))
    CALL @swiglu_tile(%input_gate -> (%temp_gate, tile_i, 0), %input_up -> (%temp_up, tile_i, 0), %output -> (%temp_swiglu, tile_i, 0))
    CALL @tile_matmul(%input_a -> (%temp_swiglu, tile_i, 0), %input_b -> %w_down, %output -> (%temp_mlp_out, tile_i, 0))
    CALL @residual_add_tile(%input -> (%temp_mlp_out, tile_i, 0), %input_residual -> (%all_hidden, tile_i, 0), %output -> (%output, tile_i, 0))
  ENDFOR
  
  return
}
