"""
PTO Code Generator for Ascend A2/A3 Cycle-Accurate Simulator

This module generates code for cycle-accurate simulation of Ascend A2/A3 NPU.

Key Features:
- Generates actual Ascend instructions for InCore functions (same as ascend_a2a3)
- Generates orchestration code with task submission for runtime scheduling
- Uses A2A3 Core Simulator for cycle-accurate execution timing
- Supports dual-queue scheduling (vector/cube)
- Generates trace output for waveform analysis

Architecture Model:
- Vector Core: handles element-wise ops, reductions, memory ops
- Cube Core: handles matrix multiply operations
- Memory Hierarchy: GM (global) -> L1/UB (scratchpad) -> Register

The simulation uses the same InCore function code as physical Ascend A2/A3,
but executes them through the core simulator for cycle-accurate timing.
"""

import os
import sys
from typing import Dict, List, Optional, Any, Tuple
from dataclasses import dataclass

# Add parent directories to path
_current_dir = os.path.dirname(os.path.abspath(__file__))
_src_dir = os.path.dirname(_current_dir)
if _src_dir not in sys.path:
    sys.path.insert(0, _src_dir)

from compile.pto_compile_common import (
    PTOProgram, PTOModule,
    MockInstruction, MockTileInfo, convert_program_to_mock_instructions,
    TileBufferAnalyzer,
)
from isa_definition.pto_isa_definition import (
    ElementType, MemorySpace,
    ARM64_TYPE_MAP,  # Reuse for C types
    ASCEND_TYPE_MAP,
    ascend_generate_header,
)

# Import AscendCodeGenerator for InCore function generation
from compile.pto_codegen_ascend import (
    AscendCodeGenerator,
    gen_ascend_barrier_op,
    gen_ascend_single_op,
    AscendFusedCodeGenerator,
)

# =============================================================================
# Cycle Cost Model for Ascend A2/A3
# =============================================================================

# Cycle costs for different operations (approximate for 910B @ 1.8GHz)
ASCEND_A2A3_CYCLE_COSTS = {
    # Memory operations (GM access is expensive)
    "TLOAD": 100,
    "TSTORE": 100,
    
    # Element-wise operations (Vector Engine)
    "TADD": 8,
    "TSUB": 8,
    "TMUL": 8,
    "TDIV": 16,
    "TEXP": 24,
    "TLOG": 24,
    "TSQRT": 16,
    "TRSQRT": 16,
    "TSILU": 20,
    "TRELU": 8,
    "TTANH": 24,
    "TSIGMOID": 24,
    "TGELU": 28,
    "TABS": 4,
    "TNEG": 4,
    
    # Scalar-tile operations
    "TADDS": 8,
    "TSUBS": 8,
    "TMULS": 8,
    "TDIVS": 16,
    "TMAXS": 8,
    "TMINS": 8,
    
    # Reduction operations
    "TROWSUM": 20,
    "TROWMAX": 20,
    "TROWMIN": 20,
    "TCOLSUM": 20,
    "TCOLMAX": 20,
    "TCOLMIN": 20,
    
    # Broadcast operations
    "TROWEXPAND": 12,
    "TCOLEXPAND": 12,
    "TROWEXPANDADD": 16,
    "TROWEXPANDSUB": 16,
    "TROWEXPANDMUL": 16,
    "TROWEXPANDDIV": 20,
    
    # Matrix operations (Cube Engine)
    "TMATMUL": 50,      # Per 32x32 output tile
    "TMATMULACC": 50,
    
    # Comparison
    "TCMP": 8,
    "TCMPS": 8,
    "TSEL": 10,
    "TSELS": 10,
    
    # Data movement
    "TMOV": 4,
    "TCVT": 8,
    "TTRANS": 16,
    
    # Control flow (negligible)
    "FOR": 1,
    "ENDFOR": 1,
    "IF": 1,
    "ELSE": 1,
    "ENDIF": 1,
    "CALL": 2,
    "RETURN": 1,
    
    # Scalar operations
    "SLI": 1,
    "SADD": 1,
    "SSUB": 1,
    "SMUL": 1,
    "SDIV": 2,
    "SCMP": 1,
}

# Which operations go to Cube Engine vs Vector Engine
CUBE_OPS = {"TMATMUL", "TMATMULACC"}
VECTOR_OPS = set(ASCEND_A2A3_CYCLE_COSTS.keys()) - CUBE_OPS - {"FOR", "ENDFOR", "IF", "ELSE", "ENDIF", "CALL", "RETURN"}


def get_cycle_cost(opcode: str, rows: int = 32, cols: int = 128) -> int:
    """
    Get cycle cost for an operation.
    
    Scales based on tile size relative to base 32x128.
    """
    base_cost = ASCEND_A2A3_CYCLE_COSTS.get(opcode, 10)
    
    # Scale by tile size
    base_elements = 32 * 128
    actual_elements = rows * cols
    scale = max(1, actual_elements // base_elements)
    
    return base_cost * scale


def is_cube_op(opcode: str) -> bool:
    """Check if operation uses Cube Engine."""
    return opcode in CUBE_OPS


# =============================================================================
# Simulation Header Generation
# =============================================================================

def generate_sim_header() -> str:
    """Generate header for simulation code."""
    return '''// PTO Ascend A2/A3 Cycle-Accurate Simulator
// Auto-generated by PTO ISA Compiler
// 
// This code uses the A2A3 Core Simulator for cycle-accurate InCore execution.
// InCore functions contain actual Ascend instructions that are parsed and
// simulated by the core model.

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include <math.h>

// Enable A2A3 platform for dual-queue simulation
#define PTO_PLATFORM_A2A3

// Include PTO runtime with simulation support
#include "pto_runtime.h"
#include "pto_runtime.c"

// Include A2A3 Core Simulator (for cycle-accurate simulation)
// Note: The core simulator is linked separately as liba2a3_core.a
// If not available, we fall back to heuristic cycle estimation

#ifdef A2A3_CORE_SIM_AVAILABLE
#include "ascend_a2a3_core_model/a2a3_core_model.h"
#include "ascend_a2a3_core_model/a2a3_incore_sim.h"
#endif

'''


def generate_incore_function_registry() -> str:
    """Generate code for registering InCore functions with the core simulator."""
    return '''
// =============================================================================
// InCore Function Registry (for Core Simulator)
// =============================================================================

#ifdef A2A3_CORE_SIM_AVAILABLE
static IncoreSimulator* g_incore_sim = NULL;

void init_incore_simulator(void) {
    if (!g_incore_sim) {
        g_incore_sim = a2a3_incore_sim_create();
    }
}

void cleanup_incore_simulator(void) {
    if (g_incore_sim) {
        a2a3_incore_sim_destroy(g_incore_sim);
        g_incore_sim = NULL;
    }
}

// Get cycle cost using core simulator
int64_t get_incore_cycle_cost_sim(const char* func_name, int64_t tile_size) {
    if (g_incore_sim) {
        return a2a3_incore_sim_execute_by_name(g_incore_sim, func_name);
    }
    return a2a3_get_incore_cycle_cost(func_name, tile_size);
}
#else
// Fallback when core simulator not available
void init_incore_simulator(void) {}
void cleanup_incore_simulator(void) {}

int64_t get_incore_cycle_cost_sim(const char* func_name, int64_t tile_size) {
    // Heuristic estimation based on function name
    if (strstr(func_name, "matmul") || strstr(func_name, "gemm")) return 50;
    if (strstr(func_name, "rmsnorm") || strstr(func_name, "layernorm")) return 70;
    if (strstr(func_name, "softmax")) return 70;
    if (strstr(func_name, "rope")) return 60;
    if (strstr(func_name, "swiglu") || strstr(func_name, "silu")) return 25;
    if (strstr(func_name, "attention") || strstr(func_name, "score")) return 60;
    if (strstr(func_name, "rowsum") || strstr(func_name, "rowmax")) return 20;
    if (strstr(func_name, "add") || strstr(func_name, "mul")) return 10;
    if (strstr(func_name, "exp") || strstr(func_name, "sqrt")) return 10;
    return 10;  // Default
}
#endif

'''


def generate_sim_main(orch_func_name: str, params: List[Tuple[str, str]]) -> str:
    """Generate main function for simulation."""
    # Build parameter declarations for test data
    param_decls = []
    param_args = []
    free_stmts = []
    
    # Track integer parameters that can be overridden via command line
    int_params = []
    int_param_idx = 0
    
    for ptype, pname in params:
        if '*' in ptype:
            # Pointer - allocate test data
            base_type = ptype.replace('*', '').strip()
            param_decls.append(f"    {base_type}* {pname} = ({base_type}*)calloc(1024 * 1024, sizeof({base_type}));")
            param_args.append(pname)
            free_stmts.append(f"    free({pname});")
        else:
            # Scalar - use default value or command line argument
            if 'int' in ptype:
                int_params.append((pname, int_param_idx))
                int_param_idx += 1
                param_decls.append(f"    {ptype} {pname} = 16;  // Default, override with argv[{int_param_idx}]")
            else:
                param_decls.append(f"    {ptype} {pname} = 1.0f;  // Default test value")
            param_args.append(pname)
    
    return f'''
// =============================================================================
// Main Function for Cycle-Accurate Simulation
// =============================================================================
// Usage: {orch_func_name} [--benchmark-only] [seq_len] [tile_rows] [num_tiles] [zero]
// Flags:
//   --benchmark-only  - Only run orchestration (skip simulation), output stats
// Environment variables:
//   PTO_TRACE_OUTPUT=file - Output trace file path

int main(int argc, char** argv) {{
    // Check for --benchmark-only flag
    int benchmark_only = 0;
    int arg_offset = 0;
    
    for (int i = 1; i < argc; i++) {{
        if (strcmp(argv[i], "--benchmark-only") == 0) {{
            benchmark_only = 1;
            arg_offset = 1;
            break;
        }}
    }}
    
    if (!benchmark_only) {{
        printf("=== Ascend A2/A3 Cycle-Accurate Simulator ===\\n");
        printf("    Platform: Ascend 910B (A2/A3)\\n");
        printf("    Workers:  %d vector + %d cube\\n", 
               A2A3_DEFAULT_VECTOR_WORKERS, A2A3_DEFAULT_CUBE_WORKERS);
#ifdef A2A3_CORE_SIM_AVAILABLE
        printf("    Core Sim: Enabled (cycle-accurate)\\n\\n");
#else
        printf("    Core Sim: Disabled (using heuristics)\\n\\n");
#endif
    }}
    
    // Initialize InCore simulator
    init_incore_simulator();
    
    // Initialize runtime (heap allocated due to large size)
    PTORuntime* rt = (PTORuntime*)calloc(1, sizeof(PTORuntime));
    if (!rt) {{
        fprintf(stderr, "Failed to allocate runtime\\n");
        return 1;
    }}
    pto_runtime_init(rt);
    
    // Enable A2A3 simulation with platform-defined worker configuration
    // A2A3 (Ascend 910B): 48 vector workers + 24 cube workers
    pto_runtime_enable_a2a3_sim(rt, A2A3_DEFAULT_VECTOR_WORKERS, A2A3_DEFAULT_CUBE_WORKERS);
    
    // Allocate test data
{chr(10).join(param_decls)}

    // Parse command line arguments for integer parameters (with offset for --benchmark-only flag)
    if (argc > 1 + arg_offset) seq_len = atoi(argv[1 + arg_offset]);
    if (argc > 2 + arg_offset) tile_rows = atoi(argv[2 + arg_offset]);
    if (argc > 3 + arg_offset) num_tiles = atoi(argv[3 + arg_offset]);
    if (argc > 4 + arg_offset) zero = atoi(argv[4 + arg_offset]);

    // Print configuration
    if (!benchmark_only) {{
        printf("Configuration:\\n");
        printf("  num_tiles = %d\\n", num_tiles);
        printf("\\nPhase 1: Building task graph...\\n");
    }}
    
    // === BENCHMARK: Measure orchestration time ===
    struct timespec start_time, end_time;
    clock_gettime(CLOCK_MONOTONIC, &start_time);
    
    // Call orchestration function to build task graph
    {orch_func_name}(rt, {", ".join(param_args)});
    
    clock_gettime(CLOCK_MONOTONIC, &end_time);
    double orch_time_ms = (end_time.tv_sec - start_time.tv_sec) * 1000.0 +
                          (end_time.tv_nsec - start_time.tv_nsec) / 1000000.0;
    // === END BENCHMARK ===
    
    int64_t tasks_submitted = rt->total_tasks_scheduled;
    
    if (benchmark_only) {{
        // Benchmark mode: just output stats in parseable format
        double tasks_per_ms = tasks_submitted / orch_time_ms;
        printf("BENCHMARK: num_tiles=%d tasks=%lld time_ms=%.3f tasks_per_ms=%.2f\\n",
               num_tiles, (long long)tasks_submitted, orch_time_ms, tasks_per_ms);
    }} else {{
        printf("  Submitted %lld tasks\\n", (long long)tasks_submitted);
        printf("  Orchestration time: %.3f ms (%.2f tasks/ms)\\n", 
               orch_time_ms, tasks_submitted / orch_time_ms);
        
        // Dump task graph before simulation
#ifdef PTO_TASK_DUMP
        pto_runtime_dump(rt, "{orch_func_name}_task_graph.txt");
#endif
        
        printf("\\nPhase 2: Running cycle-accurate simulation...\\n");
        
        // Run cycle-accurate simulation
        pto_simulate_all(rt);
        
        // Print cycle trace summary
        pto_trace_print_summary();
        
        // Save trace to JSON for visualization
        const char* trace_file = getenv("PTO_TRACE_OUTPUT");
        if (!trace_file) {{
            trace_file = "trace.json";
        }}
        pto_trace_write_json(trace_file);
        printf("Trace saved to: %s\\n", trace_file);
        printf("  Open in Chrome: chrome://tracing and load the file\\n");
    }}
    
    // Shutdown and free resources
    pto_runtime_shutdown(rt);
    free(rt);
    cleanup_incore_simulator();
    
    // Free test data
{chr(10).join(free_stmts)}
    
    if (!benchmark_only) {{
        printf("\\n=== Simulation Complete ===\\n");
    }}
    return 0;
}}
'''


# =============================================================================
# InCore Function Code Generator (uses actual Ascend instructions)
# =============================================================================

class AscendA2A3SimIncoreGenerator:
    """
    Generate InCore function code with actual Ascend instructions.
    
    This generates the same code as AscendCodeGenerator, but adds
    instrumentation for the core simulator to parse and execute.
    """
    
    def __init__(self, module: Optional[PTOModule] = None):
        self.module = module
        self.ascend_gen = AscendCodeGenerator(
            enable_fusion=True,
            analyze_buffers=True,
            module=module,
            target="a2a3"
        )
    
    def generate(self, program: PTOProgram) -> str:
        """Generate InCore function with actual Ascend instructions."""
        lines = []
        
        # Generate the actual Ascend code
        ascend_code = self.ascend_gen.generate(program)
        
        # Determine if this is a cube or vector function
        is_cube = getattr(program, 'is_cube', False)
        core_type = "CORE_TYPE_CUBE" if is_cube else "CORE_TYPE_VECTOR"
        
        # Add header comment
        lines.append(f"// =============================================================================")
        lines.append(f"// InCore Function: {program.name}")
        lines.append(f"// Core Type: {'Cube' if is_cube else 'Vector'}")
        lines.append(f"// =============================================================================")
        lines.append("")
        
        # Add the instruction code as a string constant for core simulator
        lines.append(f"// Instruction code for core simulator parsing")
        lines.append(f"static const char* {program.name}_instructions = ")
        
        # Escape the code and format as C string
        escaped_code = ascend_code.replace('\\', '\\\\').replace('"', '\\"').replace('\n', '\\n"\n    "')
        lines.append(f'    "{escaped_code}";')
        lines.append("")
        
        # Add registration function
        lines.append(f"#ifdef A2A3_CORE_SIM_AVAILABLE")
        lines.append(f"static int {program.name}_sim_registered = 0;")
        lines.append(f"")
        lines.append(f"void register_{program.name}_sim(IncoreSimulator* sim) {{")
        lines.append(f"    if (!{program.name}_sim_registered) {{")
        lines.append(f"        a2a3_incore_sim_register_code(sim, \"{program.name}\",")
        lines.append(f"            {core_type}, {program.name}_instructions, 32, 128);")
        lines.append(f"        {program.name}_sim_registered = 1;")
        lines.append(f"    }}")
        lines.append(f"}}")
        lines.append(f"#endif")
        lines.append("")
        
        # Add cycle cost function
        lines.append(f"// Get cycle cost for this function")
        lines.append(f"int64_t {program.name}_cycle_cost(int64_t tile_size) {{")
        lines.append(f"    return get_incore_cycle_cost_sim(\"{program.name}\", tile_size);")
        lines.append(f"}}")
        lines.append("")
        
        # Also include the actual Ascend code (for reference/debugging)
        lines.append("/*")
        lines.append("// Actual Ascend Instructions (for physical execution):")
        lines.append(ascend_code)
        lines.append("*/")
        
        return "\n".join(lines)


# =============================================================================
# Code Generator Class
# =============================================================================

class AscendA2A3SimCodeGenerator:
    """
    Code generator for Ascend A2/A3 cycle-accurate simulator.
    
    Generates:
    - Actual Ascend instructions for InCore functions (same as ascend_a2a3)
    - Orchestration code with task submission
    - Integration with A2A3 Core Simulator for cycle-accurate timing
    """
    
    def __init__(self, enable_fusion: bool = True, analyze_buffers: bool = True,
                 module: Optional[PTOModule] = None):
        self.enable_fusion = enable_fusion
        self.analyze_buffers = analyze_buffers
        self.module = module
        self.incore_gen = AscendA2A3SimIncoreGenerator(module)
    
    def generate(self, program: PTOProgram) -> str:
        """Generate simulation code for a program."""
        tile_info, mock_instructions = convert_program_to_mock_instructions(program)
        
        lines = []
        
        # Check if this is an orchestration function (not InCore)
        is_orchestration = not getattr(program, 'is_in_core', True)
        
        if is_orchestration:
            # Full simulation code with main() for orchestration functions
            lines.append(generate_sim_header())
            lines.append(generate_incore_function_registry())
            lines.append("")
            lines.append(self._generate_orchestration(program, mock_instructions, tile_info))
            
            # Generate main for standalone execution
            params = self._extract_params(program)
            lines.append(generate_sim_main(program.name, params))
        else:
            # For InCore functions, generate actual Ascend instructions
            lines.append(self.incore_gen.generate(program))
        
        return "\n".join(lines)
    
    def _extract_params(self, program: PTOProgram) -> List[Tuple[str, str]]:
        """Extract function parameters."""
        params = []
        
        # Memory references become pointers
        for name, memref_type in program.memref_declarations.items():
            c_type = ARM64_TYPE_MAP.get(memref_type.element_type.value, "float")
            params.append((f"{c_type}*", name))
        
        # Scalars (except internally initialized ones)
        for name, scalar_type in program.scalar_declarations.items():
            if scalar_type in (ElementType.U1, ElementType.INDEX):
                continue
            c_type = ARM64_TYPE_MAP.get(scalar_type.value, "int32_t")
            params.append((c_type, name))
        
        return params
    
    def _generate_orchestration(self, program: PTOProgram, 
                                 mock_instructions: List[MockInstruction],
                                 tile_info: Dict[str, MockTileInfo]) -> str:
        """Generate orchestration function code."""
        lines = []
        
        lines.append(f"// =============================================================================")
        lines.append(f"// Orchestration Function: {program.name}")
        lines.append(f"// Generates task graph for Ascend A2/A3 cycle-accurate simulation")
        lines.append(f"// =============================================================================")
        lines.append("")
        
        # Function signature
        params = self._extract_params(program)
        param_str = ", ".join(f"{t} {n}" for t, n in params)
        lines.append(f"void {program.name}(PTORuntime* rt, {param_str}) {{")
        lines.append("")
        
        # Task counter
        lines.append("    int32_t _task_id = 0;")
        lines.append("")
        
        # Generate code for each instruction
        indent = "    "
        task_counter = 0
        
        for instr in mock_instructions:
            opcode = instr.opcode
            
            if opcode == "TLOAD" or opcode == "TSTORE":
                # Memory ops - just track dependencies
                pass
            
            elif opcode == "CALL":
                # Generate task submission
                func_name = instr.dst
                
                # Look up is_cube from the callee function in the module
                is_cube = False
                if self.module and func_name in self.module.functions:
                    callee_prog = self.module.functions[func_name]
                    is_cube = getattr(callee_prog, 'is_cube', False)
                
                # Fallback: check if operation name suggests cube (matmul, gemm)
                if not is_cube:
                    is_cube = (is_cube_op(func_name.upper()) or 
                               "matmul" in func_name.lower() or 
                               "gemm" in func_name.lower())
                
                cycle_cost = get_cycle_cost(func_name.upper()) if func_name.upper() in ASCEND_A2A3_CYCLE_COSTS else 10
                
                lines.append(f"{indent}// Task: {func_name} ({'Cube' if is_cube else 'Vector'} Core)")
                lines.append(f"{indent}{{")
                lines.append(f"{indent}    int32_t t = pto_task_alloc(rt, \"{func_name}\", NULL, 0, 0, {'true' if is_cube else 'false'});")
                
                # Analyze callee function to determine input/output memrefs
                callee_inputs = set()
                callee_outputs = set()
                
                if self.module and func_name in self.module.functions:
                    callee_prog = self.module.functions[func_name]
                    # Analyze instructions to find LOADs (inputs) and STOREs (outputs)
                    for callee_instr in callee_prog.instructions:
                        opcode = getattr(callee_instr, 'opcode', '')
                        if opcode == 'TLOAD':
                            # TLOAD loads from src_mem → it's an input
                            src_mem = getattr(callee_instr, 'src_mem', None)
                            if src_mem:
                                callee_inputs.add(src_mem.name if hasattr(src_mem, 'name') else str(src_mem))
                        elif opcode == 'TSTORE':
                            # TSTORE stores to dst_mem → it's an output
                            dst_mem = getattr(callee_instr, 'dst_mem', None)
                            if dst_mem:
                                callee_outputs.add(dst_mem.name if hasattr(dst_mem, 'name') else str(dst_mem))
                
                # Add inputs/outputs from args
                if isinstance(instr.operands, dict):
                    for arg_name, arg_info in instr.operands.items():
                        if isinstance(arg_info, tuple) and len(arg_info) >= 3:
                            tensor, row_idx, col_idx = arg_info[0], arg_info[1], arg_info[2]
                            rows = arg_info[3] if len(arg_info) > 3 else 32
                            cols = arg_info[4] if len(arg_info) > 4 else 128
                            
                            # Determine if this is input, output, or both based on callee analysis
                            is_input = arg_name in callee_inputs or (not callee_inputs and not callee_outputs)
                            is_output = arg_name in callee_outputs
                            
                            # Fallback heuristics if analysis didn't find anything
                            if not callee_inputs and not callee_outputs:
                                is_output = 'out' in arg_name.lower() or 'dst' in arg_name.lower()
                                is_input = not is_output
                            
                            # Add both input and output if memref is read and written
                            if is_input:
                                lines.append(f"{indent}    pto_task_add_input(rt, t, {tensor}, {row_idx}, {col_idx}, {rows}, {cols});")
                            if is_output:
                                lines.append(f"{indent}    pto_task_add_output(rt, t, {tensor}, {row_idx}, {col_idx}, {rows}, {cols});")
                
                # Set cycle cost (can use core simulator or heuristic)
                lines.append(f"{indent}    // Cycle cost: {cycle_cost} (heuristic), use core sim for accurate timing")
                lines.append(f"{indent}    pto_task_submit(rt, t);")
                lines.append(f"{indent}}}")
                lines.append("")
                task_counter += 1
            
            elif opcode == "FOR":
                iv = instr.dst
                lb = instr.operands[0] if instr.operands else "0"
                ub = instr.operands[1] if len(instr.operands) > 1 else "1"
                step = instr.operands[2] if len(instr.operands) > 2 else "1"
                lines.append(f"{indent}for (int {iv} = {lb}; {iv} < {ub}; {iv} += {step}) {{")
                indent += "    "
            
            elif opcode == "ENDFOR":
                indent = indent[:-4]
                lines.append(f"{indent}}}")
            
            elif opcode == "IF":
                cond = instr.operands[0] if instr.operands else "true"
                lines.append(f"{indent}if ({cond}) {{")
                indent += "    "
            
            elif opcode == "ELSE":
                indent = indent[:-4]
                lines.append(f"{indent}}} else {{")
                indent += "    "
            
            elif opcode == "ENDIF":
                indent = indent[:-4]
                lines.append(f"{indent}}}")
            
            elif opcode == "SLI":
                # Scalar load immediate
                dst = instr.dst
                val = instr.operands[0] if instr.operands else "0"
                lines.append(f"{indent}// SLI: {dst} = {val}")
        
        lines.append("}")
        
        return "\n".join(lines)


# =============================================================================
# Convenience Functions
# =============================================================================

def generate_ascend_a2a3_sim_code(program: PTOProgram, 
                                   enable_fusion: bool = True,
                                   module: Optional[PTOModule] = None) -> str:
    """Generate Ascend A2/A3 simulation code."""
    gen = AscendA2A3SimCodeGenerator(
        enable_fusion=enable_fusion,
        module=module
    )
    return gen.generate(program)


# =============================================================================
# Export
# =============================================================================

__all__ = [
    'AscendA2A3SimCodeGenerator',
    'AscendA2A3SimIncoreGenerator',
    'generate_ascend_a2a3_sim_code',
    'ASCEND_A2A3_CYCLE_COSTS',
    'get_cycle_cost',
    'is_cube_op',
    'CUBE_OPS',
    'VECTOR_OPS',
]
