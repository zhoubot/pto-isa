// PTO Ascend A2/A3 Cycle-Accurate Simulator
// Auto-generated by PTO ISA Compiler
// 
// This code uses the A2A3 Core Simulator for cycle-accurate InCore execution.
// InCore functions contain actual Ascend instructions that are parsed and
// simulated by the core model.

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include <math.h>

// Enable A2A3 platform for dual-queue simulation
#define PTO_PLATFORM_A2A3

// Include PTO runtime with simulation support
#include "pto_runtime.h"
#include "pto_runtime.c"

// Include A2A3 Core Simulator (for cycle-accurate simulation)
// Note: The core simulator is linked separately as liba2a3_core.a
// If not available, we fall back to heuristic cycle estimation

#ifdef A2A3_CORE_SIM_AVAILABLE
#include "ascend_a2a3_core_model/a2a3_core_model.h"
#include "ascend_a2a3_core_model/a2a3_incore_sim.h"
#endif



// =============================================================================
// InCore Function Registry (for Core Simulator)
// =============================================================================

#ifdef A2A3_CORE_SIM_AVAILABLE
static IncoreSimulator* g_incore_sim = NULL;

void init_incore_simulator(void) {
    if (!g_incore_sim) {
        g_incore_sim = a2a3_incore_sim_create();
    }
}

void cleanup_incore_simulator(void) {
    if (g_incore_sim) {
        a2a3_incore_sim_destroy(g_incore_sim);
        g_incore_sim = NULL;
    }
}

// Get cycle cost using core simulator
int64_t get_incore_cycle_cost_sim(const char* func_name, int64_t tile_size) {
    if (g_incore_sim) {
        return a2a3_incore_sim_execute_by_name(g_incore_sim, func_name);
    }
    return a2a3_get_incore_cycle_cost(func_name, tile_size);
}
#else
// Fallback when core simulator not available
void init_incore_simulator(void) {}
void cleanup_incore_simulator(void) {}

int64_t get_incore_cycle_cost_sim(const char* func_name, int64_t tile_size) {
    // Heuristic estimation based on function name
    if (strstr(func_name, "matmul") || strstr(func_name, "gemm")) return 50;
    if (strstr(func_name, "rmsnorm") || strstr(func_name, "layernorm")) return 70;
    if (strstr(func_name, "softmax")) return 70;
    if (strstr(func_name, "rope")) return 60;
    if (strstr(func_name, "swiglu") || strstr(func_name, "silu")) return 25;
    if (strstr(func_name, "attention") || strstr(func_name, "score")) return 60;
    if (strstr(func_name, "rowsum") || strstr(func_name, "rowmax")) return 20;
    if (strstr(func_name, "add") || strstr(func_name, "mul")) return 10;
    if (strstr(func_name, "exp") || strstr(func_name, "sqrt")) return 10;
    return 10;  // Default
}
#endif



// =============================================================================
// Orchestration Function: bgemm_dynamic
// Generates task graph for Ascend A2/A3 cycle-accurate simulation
// =============================================================================

void bgemm_dynamic(PTORuntime* rt, float* A, float* B, float* C, float* P0, float* P1, float* P2, int32_t seq_len, int32_t tile_rows, int32_t num_tiles, float zero) {

    int32_t _task_id = 0;

    for (int tile = 0; tile < num_tiles; tile += 1) {
        // Task: gemm_tile (Cube Core)
        {
            int32_t t = pto_task_alloc(rt, "gemm_tile", NULL, 0, 0, true);
            pto_task_add_input(rt, t, A, tile * 8 + 0, 0, 64, 64);
            pto_task_add_input(rt, t, B, 0 * num_tiles + tile, 0, 64, 128);
            pto_task_add_output(rt, t, P0, tile * 8 + 0, 0, 64, 128);
            // Cycle cost: 10 (heuristic), use core sim for accurate timing
            pto_task_submit(rt, t);
        }

        // Task: gemm_tile (Cube Core)
        {
            int32_t t = pto_task_alloc(rt, "gemm_tile", NULL, 0, 0, true);
            pto_task_add_input(rt, t, A, tile * 8 + 1, 0, 64, 64);
            pto_task_add_input(rt, t, B, 1 * num_tiles + tile, 0, 64, 128);
            pto_task_add_output(rt, t, P0, tile * 8 + 1, 0, 64, 128);
            // Cycle cost: 10 (heuristic), use core sim for accurate timing
            pto_task_submit(rt, t);
        }

        // Task: gemm_tile (Cube Core)
        {
            int32_t t = pto_task_alloc(rt, "gemm_tile", NULL, 0, 0, true);
            pto_task_add_input(rt, t, A, tile * 8 + 2, 0, 64, 64);
            pto_task_add_input(rt, t, B, 2 * num_tiles + tile, 0, 64, 128);
            pto_task_add_output(rt, t, P0, tile * 8 + 2, 0, 64, 128);
            // Cycle cost: 10 (heuristic), use core sim for accurate timing
            pto_task_submit(rt, t);
        }

        // Task: gemm_tile (Cube Core)
        {
            int32_t t = pto_task_alloc(rt, "gemm_tile", NULL, 0, 0, true);
            pto_task_add_input(rt, t, A, tile * 8 + 3, 0, 64, 64);
            pto_task_add_input(rt, t, B, 3 * num_tiles + tile, 0, 64, 128);
            pto_task_add_output(rt, t, P0, tile * 8 + 3, 0, 64, 128);
            // Cycle cost: 10 (heuristic), use core sim for accurate timing
            pto_task_submit(rt, t);
        }

        // Task: gemm_tile (Cube Core)
        {
            int32_t t = pto_task_alloc(rt, "gemm_tile", NULL, 0, 0, true);
            pto_task_add_input(rt, t, A, tile * 8 + 4, 0, 64, 64);
            pto_task_add_input(rt, t, B, 4 * num_tiles + tile, 0, 64, 128);
            pto_task_add_output(rt, t, P0, tile * 8 + 4, 0, 64, 128);
            // Cycle cost: 10 (heuristic), use core sim for accurate timing
            pto_task_submit(rt, t);
        }

        // Task: gemm_tile (Cube Core)
        {
            int32_t t = pto_task_alloc(rt, "gemm_tile", NULL, 0, 0, true);
            pto_task_add_input(rt, t, A, tile * 8 + 5, 0, 64, 64);
            pto_task_add_input(rt, t, B, 5 * num_tiles + tile, 0, 64, 128);
            pto_task_add_output(rt, t, P0, tile * 8 + 5, 0, 64, 128);
            // Cycle cost: 10 (heuristic), use core sim for accurate timing
            pto_task_submit(rt, t);
        }

        // Task: gemm_tile (Cube Core)
        {
            int32_t t = pto_task_alloc(rt, "gemm_tile", NULL, 0, 0, true);
            pto_task_add_input(rt, t, A, tile * 8 + 6, 0, 64, 64);
            pto_task_add_input(rt, t, B, 6 * num_tiles + tile, 0, 64, 128);
            pto_task_add_output(rt, t, P0, tile * 8 + 6, 0, 64, 128);
            // Cycle cost: 10 (heuristic), use core sim for accurate timing
            pto_task_submit(rt, t);
        }

        // Task: gemm_tile (Cube Core)
        {
            int32_t t = pto_task_alloc(rt, "gemm_tile", NULL, 0, 0, true);
            pto_task_add_input(rt, t, A, tile * 8 + 7, 0, 64, 64);
            pto_task_add_input(rt, t, B, 7 * num_tiles + tile, 0, 64, 128);
            pto_task_add_output(rt, t, P0, tile * 8 + 7, 0, 64, 128);
            // Cycle cost: 10 (heuristic), use core sim for accurate timing
            pto_task_submit(rt, t);
        }

        // Task: tile_add (Vector Core)
        {
            int32_t t = pto_task_alloc(rt, "tile_add", NULL, 0, 0, false);
            pto_task_add_input(rt, t, P0, tile * 8 + 0, 0, 64, 128);
            pto_task_add_input(rt, t, P0, tile * 8 + 1, 0, 64, 128);
            pto_task_add_output(rt, t, P1, tile * 4 + 0, 0, 64, 128);
            // Cycle cost: 10 (heuristic), use core sim for accurate timing
            pto_task_submit(rt, t);
        }

        // Task: tile_add (Vector Core)
        {
            int32_t t = pto_task_alloc(rt, "tile_add", NULL, 0, 0, false);
            pto_task_add_input(rt, t, P0, tile * 8 + 2, 0, 64, 128);
            pto_task_add_input(rt, t, P0, tile * 8 + 3, 0, 64, 128);
            pto_task_add_output(rt, t, P1, tile * 4 + 1, 0, 64, 128);
            // Cycle cost: 10 (heuristic), use core sim for accurate timing
            pto_task_submit(rt, t);
        }

        // Task: tile_add (Vector Core)
        {
            int32_t t = pto_task_alloc(rt, "tile_add", NULL, 0, 0, false);
            pto_task_add_input(rt, t, P0, tile * 8 + 4, 0, 64, 128);
            pto_task_add_input(rt, t, P0, tile * 8 + 5, 0, 64, 128);
            pto_task_add_output(rt, t, P1, tile * 4 + 2, 0, 64, 128);
            // Cycle cost: 10 (heuristic), use core sim for accurate timing
            pto_task_submit(rt, t);
        }

        // Task: tile_add (Vector Core)
        {
            int32_t t = pto_task_alloc(rt, "tile_add", NULL, 0, 0, false);
            pto_task_add_input(rt, t, P0, tile * 8 + 6, 0, 64, 128);
            pto_task_add_input(rt, t, P0, tile * 8 + 7, 0, 64, 128);
            pto_task_add_output(rt, t, P1, tile * 4 + 3, 0, 64, 128);
            // Cycle cost: 10 (heuristic), use core sim for accurate timing
            pto_task_submit(rt, t);
        }

        // Task: tile_add (Vector Core)
        {
            int32_t t = pto_task_alloc(rt, "tile_add", NULL, 0, 0, false);
            pto_task_add_input(rt, t, P1, tile * 4 + 0, 0, 64, 128);
            pto_task_add_input(rt, t, P1, tile * 4 + 1, 0, 64, 128);
            pto_task_add_output(rt, t, P2, tile * 2 + 0, 0, 64, 128);
            // Cycle cost: 10 (heuristic), use core sim for accurate timing
            pto_task_submit(rt, t);
        }

        // Task: tile_add (Vector Core)
        {
            int32_t t = pto_task_alloc(rt, "tile_add", NULL, 0, 0, false);
            pto_task_add_input(rt, t, P1, tile * 4 + 2, 0, 64, 128);
            pto_task_add_input(rt, t, P1, tile * 4 + 3, 0, 64, 128);
            pto_task_add_output(rt, t, P2, tile * 2 + 1, 0, 64, 128);
            // Cycle cost: 10 (heuristic), use core sim for accurate timing
            pto_task_submit(rt, t);
        }

        // Task: tile_add (Vector Core)
        {
            int32_t t = pto_task_alloc(rt, "tile_add", NULL, 0, 0, false);
            pto_task_add_input(rt, t, P2, tile * 2 + 0, 0, 64, 128);
            pto_task_add_input(rt, t, P2, tile * 2 + 1, 0, 64, 128);
            pto_task_add_output(rt, t, C, tile, 0, 64, 128);
            // Cycle cost: 10 (heuristic), use core sim for accurate timing
            pto_task_submit(rt, t);
        }

    }
}

// =============================================================================
// Main Function for Cycle-Accurate Simulation
// =============================================================================
// Usage: bgemm_dynamic [--benchmark-only] [seq_len] [tile_rows] [num_tiles] [zero]
// Flags:
//   --benchmark-only  - Only run orchestration (skip simulation), output stats
// Environment variables:
//   PTO_TRACE_OUTPUT=file - Output trace file path

int main(int argc, char** argv) {
    // Check for --benchmark-only flag
    int benchmark_only = 0;
    int arg_offset = 0;
    
    for (int i = 1; i < argc; i++) {
        if (strcmp(argv[i], "--benchmark-only") == 0) {
            benchmark_only = 1;
            arg_offset = 1;
            break;
        }
    }
    
    if (!benchmark_only) {
        printf("=== Ascend A2/A3 Cycle-Accurate Simulator ===\n");
        printf("    Platform: Ascend 910B (A2/A3)\n");
        printf("    Workers:  %d vector + %d cube\n", 
               A2A3_DEFAULT_VECTOR_WORKERS, A2A3_DEFAULT_CUBE_WORKERS);
#ifdef A2A3_CORE_SIM_AVAILABLE
        printf("    Core Sim: Enabled (cycle-accurate)\n\n");
#else
        printf("    Core Sim: Disabled (using heuristics)\n\n");
#endif
    }
    
    // Initialize InCore simulator
    init_incore_simulator();
    
    // Initialize runtime (heap allocated due to large size)
    PTORuntime* rt = (PTORuntime*)calloc(1, sizeof(PTORuntime));
    if (!rt) {
        fprintf(stderr, "Failed to allocate runtime\n");
        return 1;
    }
    pto_runtime_init(rt);
    
    // Enable A2A3 simulation with platform-defined worker configuration
    // A2A3 (Ascend 910B): 48 vector workers + 24 cube workers
    pto_runtime_enable_a2a3_sim(rt, A2A3_DEFAULT_VECTOR_WORKERS, A2A3_DEFAULT_CUBE_WORKERS);
    
    // Allocate test data
    float* A = (float*)calloc(1024 * 1024, sizeof(float));
    float* B = (float*)calloc(1024 * 1024, sizeof(float));
    float* C = (float*)calloc(1024 * 1024, sizeof(float));
    float* P0 = (float*)calloc(1024 * 1024, sizeof(float));
    float* P1 = (float*)calloc(1024 * 1024, sizeof(float));
    float* P2 = (float*)calloc(1024 * 1024, sizeof(float));
    int32_t seq_len = 16;  // Default, override with argv[1]
    int32_t tile_rows = 16;  // Default, override with argv[2]
    int32_t num_tiles = 16;  // Default, override with argv[3]
    float zero = 1.0f;  // Default test value

    // Parse command line arguments for integer parameters (with offset for --benchmark-only flag)
    if (argc > 1 + arg_offset) seq_len = atoi(argv[1 + arg_offset]);
    if (argc > 2 + arg_offset) tile_rows = atoi(argv[2 + arg_offset]);
    if (argc > 3 + arg_offset) num_tiles = atoi(argv[3 + arg_offset]);
    if (argc > 4 + arg_offset) zero = atoi(argv[4 + arg_offset]);

    // Print configuration
    if (!benchmark_only) {
        printf("Configuration:\n");
        printf("  num_tiles = %d\n", num_tiles);
        printf("\nPhase 1: Building task graph...\n");
    }
    
    // === BENCHMARK: Measure orchestration time ===
    struct timespec start_time, end_time;
    clock_gettime(CLOCK_MONOTONIC, &start_time);
    
    // Call orchestration function to build task graph
    bgemm_dynamic(rt, A, B, C, P0, P1, P2, seq_len, tile_rows, num_tiles, zero);
    
    clock_gettime(CLOCK_MONOTONIC, &end_time);
    double orch_time_ms = (end_time.tv_sec - start_time.tv_sec) * 1000.0 +
                          (end_time.tv_nsec - start_time.tv_nsec) / 1000000.0;
    // === END BENCHMARK ===
    
    int64_t tasks_submitted = rt->total_tasks_scheduled;
    
    if (benchmark_only) {
        // Benchmark mode: just output stats in parseable format
        double tasks_per_ms = tasks_submitted / orch_time_ms;
        printf("BENCHMARK: num_tiles=%d tasks=%lld time_ms=%.3f tasks_per_ms=%.2f\n",
               num_tiles, (long long)tasks_submitted, orch_time_ms, tasks_per_ms);
    } else {
        printf("  Submitted %lld tasks\n", (long long)tasks_submitted);
        printf("  Orchestration time: %.3f ms (%.2f tasks/ms)\n", 
               orch_time_ms, tasks_submitted / orch_time_ms);
        
        // Dump task graph before simulation
#ifdef PTO_TASK_DUMP
        pto_runtime_dump(rt, "bgemm_dynamic_task_graph.txt");
#endif
        
        printf("\nPhase 2: Running cycle-accurate simulation...\n");
        
        // Run cycle-accurate simulation
        pto_simulate_all(rt);
        
        // Print cycle trace summary
        pto_trace_print_summary();
        
        // Save trace to JSON for visualization
        const char* trace_file = getenv("PTO_TRACE_OUTPUT");
        if (!trace_file) {
            trace_file = "trace.json";
        }
        pto_trace_write_json(trace_file);
        printf("Trace saved to: %s\n", trace_file);
        printf("  Open in Chrome: chrome://tracing and load the file\n");
    }
    
    // Shutdown and free resources
    pto_runtime_shutdown(rt);
    free(rt);
    cleanup_incore_simulator();
    
    // Free test data
    free(A);
    free(B);
    free(C);
    free(P0);
    free(P1);
    free(P2);
    
    if (!benchmark_only) {
        printf("\n=== Simulation Complete ===\n");
    }
    return 0;
}
