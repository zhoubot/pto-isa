// PTO Ascend A2/A3 Cycle-Accurate Simulator
// Auto-generated by PTO ISA Compiler
// 
// This code uses the A2A3 Core Simulator for cycle-accurate InCore execution.
// InCore functions contain actual Ascend instructions that are parsed and
// simulated by the core model.

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include <math.h>

// Enable A2A3 platform for dual-queue simulation
#define PTO_PLATFORM_A2A3

// Include PTO runtime with simulation support
#include "pto_runtime.h"
#include "pto_runtime.c"

// Include A2A3 Core Simulator (for cycle-accurate simulation)
// Note: The core simulator is linked separately as liba2a3_core.a
// If not available, we fall back to heuristic cycle estimation

#ifdef A2A3_CORE_SIM_AVAILABLE
#include "ascend_a2a3_core_model/a2a3_core_model.h"
#include "ascend_a2a3_core_model/a2a3_incore_sim.h"
#endif



// =============================================================================
// InCore Function Registry (for Core Simulator)
// =============================================================================

#ifdef A2A3_CORE_SIM_AVAILABLE
static IncoreSimulator* g_incore_sim = NULL;

void init_incore_simulator(void) {
    if (!g_incore_sim) {
        g_incore_sim = a2a3_incore_sim_create();
    }
}

void cleanup_incore_simulator(void) {
    if (g_incore_sim) {
        a2a3_incore_sim_destroy(g_incore_sim);
        g_incore_sim = NULL;
    }
}

// Get cycle cost using core simulator
int64_t get_incore_cycle_cost_sim(const char* func_name, int64_t tile_size) {
    if (g_incore_sim) {
        return a2a3_incore_sim_execute_by_name(g_incore_sim, func_name);
    }
    return a2a3_get_incore_cycle_cost(func_name, tile_size);
}
#else
// Fallback when core simulator not available
void init_incore_simulator(void) {}
void cleanup_incore_simulator(void) {}

int64_t get_incore_cycle_cost_sim(const char* func_name, int64_t tile_size) {
    // Heuristic estimation based on function name
    if (strstr(func_name, "matmul") || strstr(func_name, "gemm")) return 50;
    if (strstr(func_name, "rmsnorm") || strstr(func_name, "layernorm")) return 70;
    if (strstr(func_name, "softmax")) return 70;
    if (strstr(func_name, "rope")) return 60;
    if (strstr(func_name, "swiglu") || strstr(func_name, "silu")) return 25;
    if (strstr(func_name, "attention") || strstr(func_name, "score")) return 60;
    if (strstr(func_name, "rowsum") || strstr(func_name, "rowmax")) return 20;
    if (strstr(func_name, "add") || strstr(func_name, "mul")) return 10;
    if (strstr(func_name, "exp") || strstr(func_name, "sqrt")) return 10;
    return 10;  // Default
}
#endif



// =============================================================================
// Orchestration Function: llama_layer_dynamic
// Generates task graph for Ascend A2/A3 cycle-accurate simulation
// =============================================================================

void llama_layer_dynamic(PTORuntime* rt, float* input, float* output, float* attn_norm_weights, float* wq, float* wk, float* wv, float* wo, float* cos_cache, float* sin_cache, float* mlp_norm_weights, float* w_gate, float* w_up, float* w_down, float* all_q_tiles, float* all_k_tiles, float* all_v_tiles, float* all_q_rope, float* all_k_rope, float* all_attn_out, float* all_m_vec, float* all_l_vec, float* all_hidden, float* temp_norm, float* temp_scores, float* temp_attn_weights, float* temp_scale, float* temp_gate, float* temp_up, float* temp_swiglu, float* temp_mlp_out, float* const_zeros_large, float* const_zeros_small, float* const_neg_inf, int32_t seq_len, int32_t tile_rows, int32_t num_tiles, int32_t zero) {

    int32_t _task_id = 0;

    for (int tile_i = 0; tile_i < num_tiles; tile_i += 1) {
        // Task: rmsnorm_tile (Vector Core)
        {
            int32_t t = pto_task_alloc(rt, "rmsnorm_tile", NULL, 0, 0, false);
            pto_task_add_input(rt, t, input, tile_i, 0, 32, 128);
            pto_task_add_output(rt, t, temp_norm, tile_i, 0, 32, 128);
            // Cycle cost: 10 (heuristic), use core sim for accurate timing
            pto_task_submit(rt, t);
        }

        // Task: tile_matmul (Cube Core)
        {
            int32_t t = pto_task_alloc(rt, "tile_matmul", NULL, 0, 0, true);
            pto_task_add_input(rt, t, temp_norm, tile_i, 0, 32, 128);
            pto_task_add_output(rt, t, all_q_tiles, tile_i, 0, 32, 128);
            // Cycle cost: 10 (heuristic), use core sim for accurate timing
            pto_task_submit(rt, t);
        }

        // Task: tile_matmul (Cube Core)
        {
            int32_t t = pto_task_alloc(rt, "tile_matmul", NULL, 0, 0, true);
            pto_task_add_input(rt, t, temp_norm, tile_i, 0, 32, 128);
            pto_task_add_output(rt, t, all_k_tiles, tile_i, 0, 32, 128);
            // Cycle cost: 10 (heuristic), use core sim for accurate timing
            pto_task_submit(rt, t);
        }

        // Task: tile_matmul (Cube Core)
        {
            int32_t t = pto_task_alloc(rt, "tile_matmul", NULL, 0, 0, true);
            pto_task_add_input(rt, t, temp_norm, tile_i, 0, 32, 128);
            pto_task_add_output(rt, t, all_v_tiles, tile_i, 0, 32, 128);
            // Cycle cost: 10 (heuristic), use core sim for accurate timing
            pto_task_submit(rt, t);
        }

        // Task: rope_tile (Vector Core)
        {
            int32_t t = pto_task_alloc(rt, "rope_tile", NULL, 0, 0, false);
            pto_task_add_input(rt, t, all_q_tiles, tile_i, 0, 32, 128);
            pto_task_add_output(rt, t, all_q_rope, tile_i, 0, 32, 128);
            // Cycle cost: 10 (heuristic), use core sim for accurate timing
            pto_task_submit(rt, t);
        }

        // Task: rope_tile (Vector Core)
        {
            int32_t t = pto_task_alloc(rt, "rope_tile", NULL, 0, 0, false);
            pto_task_add_input(rt, t, all_k_tiles, tile_i, 0, 32, 128);
            pto_task_add_output(rt, t, all_k_rope, tile_i, 0, 32, 128);
            // Cycle cost: 10 (heuristic), use core sim for accurate timing
            pto_task_submit(rt, t);
        }

    }
    for (int q_tile = 0; q_tile < num_tiles; q_tile += 1) {
        // Task: flash_attn_init_state (Vector Core)
        {
            int32_t t = pto_task_alloc(rt, "flash_attn_init_state", NULL, 0, 0, false);
            pto_task_add_output(rt, t, all_attn_out, q_tile, 0, 32, 128);
            pto_task_add_output(rt, t, all_l_vec, q_tile, 0, 32, 128);
            pto_task_add_output(rt, t, all_m_vec, q_tile, 0, 32, 128);
            // Cycle cost: 10 (heuristic), use core sim for accurate timing
            pto_task_submit(rt, t);
        }

        for (int kv_tile = 0; kv_tile < num_tiles; kv_tile += 1) {
            // Task: flash_attn_score_block (Vector Core)
            {
                int32_t t = pto_task_alloc(rt, "flash_attn_score_block", NULL, 0, 0, false);
                pto_task_add_input(rt, t, all_q_rope, q_tile, 0, 32, 128);
                pto_task_add_input(rt, t, all_k_rope, kv_tile, 0, 32, 128);
                pto_task_add_output(rt, t, temp_scores, q_tile, 0, 32, 128);
                // Cycle cost: 10 (heuristic), use core sim for accurate timing
                pto_task_submit(rt, t);
            }

            // Task: flash_attn_softmax_update (Vector Core)
            {
                int32_t t = pto_task_alloc(rt, "flash_attn_softmax_update", NULL, 0, 0, false);
                pto_task_add_input(rt, t, temp_scores, q_tile, 0, 32, 128);
                pto_task_add_input(rt, t, all_m_vec, q_tile, 0, 32, 128);
                pto_task_add_input(rt, t, all_l_vec, q_tile, 0, 32, 128);
                pto_task_add_output(rt, t, all_m_vec, q_tile, 0, 32, 128);
                pto_task_add_output(rt, t, all_l_vec, q_tile, 0, 32, 128);
                pto_task_add_output(rt, t, temp_attn_weights, q_tile, 0, 32, 128);
                pto_task_add_output(rt, t, temp_scale, q_tile, 0, 32, 128);
                // Cycle cost: 10 (heuristic), use core sim for accurate timing
                pto_task_submit(rt, t);
            }

            // Task: flash_attn_output_update (Vector Core)
            {
                int32_t t = pto_task_alloc(rt, "flash_attn_output_update", NULL, 0, 0, false);
                pto_task_add_input(rt, t, all_attn_out, q_tile, 0, 32, 128);
                pto_task_add_input(rt, t, temp_attn_weights, q_tile, 0, 32, 128);
                pto_task_add_input(rt, t, all_v_tiles, kv_tile, 0, 32, 128);
                pto_task_add_input(rt, t, temp_scale, q_tile, 0, 32, 128);
                pto_task_add_output(rt, t, all_attn_out, q_tile, 0, 32, 128);
                // Cycle cost: 10 (heuristic), use core sim for accurate timing
                pto_task_submit(rt, t);
            }

        }
        // Task: flash_attn_normalize (Vector Core)
        {
            int32_t t = pto_task_alloc(rt, "flash_attn_normalize", NULL, 0, 0, false);
            pto_task_add_input(rt, t, all_attn_out, q_tile, 0, 32, 128);
            pto_task_add_input(rt, t, all_l_vec, q_tile, 0, 32, 128);
            pto_task_add_output(rt, t, all_attn_out, q_tile, 0, 32, 128);
            // Cycle cost: 10 (heuristic), use core sim for accurate timing
            pto_task_submit(rt, t);
        }

    }
    for (int tile_i = 0; tile_i < num_tiles; tile_i += 1) {
        // Task: tile_matmul (Cube Core)
        {
            int32_t t = pto_task_alloc(rt, "tile_matmul", NULL, 0, 0, true);
            pto_task_add_input(rt, t, all_attn_out, tile_i, 0, 32, 128);
            pto_task_add_output(rt, t, temp_norm, tile_i, 0, 32, 128);
            // Cycle cost: 10 (heuristic), use core sim for accurate timing
            pto_task_submit(rt, t);
        }

        // Task: residual_add_tile (Vector Core)
        {
            int32_t t = pto_task_alloc(rt, "residual_add_tile", NULL, 0, 0, false);
            pto_task_add_input(rt, t, temp_norm, tile_i, 0, 32, 128);
            pto_task_add_input(rt, t, input, tile_i, 0, 32, 128);
            pto_task_add_output(rt, t, all_hidden, tile_i, 0, 32, 128);
            // Cycle cost: 10 (heuristic), use core sim for accurate timing
            pto_task_submit(rt, t);
        }

        // Task: rmsnorm_tile (Vector Core)
        {
            int32_t t = pto_task_alloc(rt, "rmsnorm_tile", NULL, 0, 0, false);
            pto_task_add_input(rt, t, all_hidden, tile_i, 0, 32, 128);
            pto_task_add_output(rt, t, temp_norm, tile_i, 0, 32, 128);
            // Cycle cost: 10 (heuristic), use core sim for accurate timing
            pto_task_submit(rt, t);
        }

        // Task: tile_matmul (Cube Core)
        {
            int32_t t = pto_task_alloc(rt, "tile_matmul", NULL, 0, 0, true);
            pto_task_add_input(rt, t, temp_norm, tile_i, 0, 32, 128);
            pto_task_add_output(rt, t, temp_gate, tile_i, 0, 32, 128);
            // Cycle cost: 10 (heuristic), use core sim for accurate timing
            pto_task_submit(rt, t);
        }

        // Task: tile_matmul (Cube Core)
        {
            int32_t t = pto_task_alloc(rt, "tile_matmul", NULL, 0, 0, true);
            pto_task_add_input(rt, t, temp_norm, tile_i, 0, 32, 128);
            pto_task_add_output(rt, t, temp_up, tile_i, 0, 32, 128);
            // Cycle cost: 10 (heuristic), use core sim for accurate timing
            pto_task_submit(rt, t);
        }

        // Task: swiglu_tile (Vector Core)
        {
            int32_t t = pto_task_alloc(rt, "swiglu_tile", NULL, 0, 0, false);
            pto_task_add_input(rt, t, temp_gate, tile_i, 0, 32, 128);
            pto_task_add_input(rt, t, temp_up, tile_i, 0, 32, 128);
            pto_task_add_output(rt, t, temp_swiglu, tile_i, 0, 32, 128);
            // Cycle cost: 10 (heuristic), use core sim for accurate timing
            pto_task_submit(rt, t);
        }

        // Task: tile_matmul (Cube Core)
        {
            int32_t t = pto_task_alloc(rt, "tile_matmul", NULL, 0, 0, true);
            pto_task_add_input(rt, t, temp_swiglu, tile_i, 0, 32, 128);
            pto_task_add_output(rt, t, temp_mlp_out, tile_i, 0, 32, 128);
            // Cycle cost: 10 (heuristic), use core sim for accurate timing
            pto_task_submit(rt, t);
        }

        // Task: residual_add_tile (Vector Core)
        {
            int32_t t = pto_task_alloc(rt, "residual_add_tile", NULL, 0, 0, false);
            pto_task_add_input(rt, t, temp_mlp_out, tile_i, 0, 32, 128);
            pto_task_add_input(rt, t, all_hidden, tile_i, 0, 32, 128);
            pto_task_add_output(rt, t, output, tile_i, 0, 32, 128);
            // Cycle cost: 10 (heuristic), use core sim for accurate timing
            pto_task_submit(rt, t);
        }

    }
}

// =============================================================================
// Main Function for Cycle-Accurate Simulation
// =============================================================================
// Usage: llama_layer_dynamic [--benchmark-only] [seq_len] [tile_rows] [num_tiles] [zero]
// Flags:
//   --benchmark-only  - Only run orchestration (skip simulation), output stats
// Environment variables:
//   PTO_TRACE_OUTPUT=file - Output trace file path

int main(int argc, char** argv) {
    // Check for --benchmark-only flag
    int benchmark_only = 0;
    int arg_offset = 0;
    
    for (int i = 1; i < argc; i++) {
        if (strcmp(argv[i], "--benchmark-only") == 0) {
            benchmark_only = 1;
            arg_offset = 1;
            break;
        }
    }
    
    if (!benchmark_only) {
        printf("=== Ascend A2/A3 Cycle-Accurate Simulator ===\n");
        printf("    Platform: Ascend 910B (A2/A3)\n");
        printf("    Workers:  %d vector + %d cube\n", 
               A2A3_DEFAULT_VECTOR_WORKERS, A2A3_DEFAULT_CUBE_WORKERS);
#ifdef A2A3_CORE_SIM_AVAILABLE
        printf("    Core Sim: Enabled (cycle-accurate)\n\n");
#else
        printf("    Core Sim: Disabled (using heuristics)\n\n");
#endif
    }
    
    // Initialize InCore simulator
    init_incore_simulator();
    
    // Initialize runtime (heap allocated due to large size)
    PTORuntime* rt = (PTORuntime*)calloc(1, sizeof(PTORuntime));
    if (!rt) {
        fprintf(stderr, "Failed to allocate runtime\n");
        return 1;
    }
    pto_runtime_init(rt);
    
    // Enable A2A3 simulation with platform-defined worker configuration
    // A2A3 (Ascend 910B): 48 vector workers + 24 cube workers
    pto_runtime_enable_a2a3_sim(rt, A2A3_DEFAULT_VECTOR_WORKERS, A2A3_DEFAULT_CUBE_WORKERS);
    
    // Allocate test data
    float* input = (float*)calloc(1024 * 1024, sizeof(float));
    float* output = (float*)calloc(1024 * 1024, sizeof(float));
    float* attn_norm_weights = (float*)calloc(1024 * 1024, sizeof(float));
    float* wq = (float*)calloc(1024 * 1024, sizeof(float));
    float* wk = (float*)calloc(1024 * 1024, sizeof(float));
    float* wv = (float*)calloc(1024 * 1024, sizeof(float));
    float* wo = (float*)calloc(1024 * 1024, sizeof(float));
    float* cos_cache = (float*)calloc(1024 * 1024, sizeof(float));
    float* sin_cache = (float*)calloc(1024 * 1024, sizeof(float));
    float* mlp_norm_weights = (float*)calloc(1024 * 1024, sizeof(float));
    float* w_gate = (float*)calloc(1024 * 1024, sizeof(float));
    float* w_up = (float*)calloc(1024 * 1024, sizeof(float));
    float* w_down = (float*)calloc(1024 * 1024, sizeof(float));
    float* all_q_tiles = (float*)calloc(1024 * 1024, sizeof(float));
    float* all_k_tiles = (float*)calloc(1024 * 1024, sizeof(float));
    float* all_v_tiles = (float*)calloc(1024 * 1024, sizeof(float));
    float* all_q_rope = (float*)calloc(1024 * 1024, sizeof(float));
    float* all_k_rope = (float*)calloc(1024 * 1024, sizeof(float));
    float* all_attn_out = (float*)calloc(1024 * 1024, sizeof(float));
    float* all_m_vec = (float*)calloc(1024 * 1024, sizeof(float));
    float* all_l_vec = (float*)calloc(1024 * 1024, sizeof(float));
    float* all_hidden = (float*)calloc(1024 * 1024, sizeof(float));
    float* temp_norm = (float*)calloc(1024 * 1024, sizeof(float));
    float* temp_scores = (float*)calloc(1024 * 1024, sizeof(float));
    float* temp_attn_weights = (float*)calloc(1024 * 1024, sizeof(float));
    float* temp_scale = (float*)calloc(1024 * 1024, sizeof(float));
    float* temp_gate = (float*)calloc(1024 * 1024, sizeof(float));
    float* temp_up = (float*)calloc(1024 * 1024, sizeof(float));
    float* temp_swiglu = (float*)calloc(1024 * 1024, sizeof(float));
    float* temp_mlp_out = (float*)calloc(1024 * 1024, sizeof(float));
    float* const_zeros_large = (float*)calloc(1024 * 1024, sizeof(float));
    float* const_zeros_small = (float*)calloc(1024 * 1024, sizeof(float));
    float* const_neg_inf = (float*)calloc(1024 * 1024, sizeof(float));
    int32_t seq_len = 16;  // Default, override with argv[1]
    int32_t tile_rows = 16;  // Default, override with argv[2]
    int32_t num_tiles = 16;  // Default, override with argv[3]
    int32_t zero = 16;  // Default, override with argv[4]

    // Parse command line arguments for integer parameters (with offset for --benchmark-only flag)
    if (argc > 1 + arg_offset) seq_len = atoi(argv[1 + arg_offset]);
    if (argc > 2 + arg_offset) tile_rows = atoi(argv[2 + arg_offset]);
    if (argc > 3 + arg_offset) num_tiles = atoi(argv[3 + arg_offset]);
    if (argc > 4 + arg_offset) zero = atoi(argv[4 + arg_offset]);

    // Print configuration
    if (!benchmark_only) {
        printf("Configuration:\n");
        printf("  num_tiles = %d\n", num_tiles);
        printf("\nPhase 1: Building task graph...\n");
    }
    
    // === BENCHMARK: Measure orchestration time ===
    struct timespec start_time, end_time;
    clock_gettime(CLOCK_MONOTONIC, &start_time);
    
    // Call orchestration function to build task graph
    llama_layer_dynamic(rt, input, output, attn_norm_weights, wq, wk, wv, wo, cos_cache, sin_cache, mlp_norm_weights, w_gate, w_up, w_down, all_q_tiles, all_k_tiles, all_v_tiles, all_q_rope, all_k_rope, all_attn_out, all_m_vec, all_l_vec, all_hidden, temp_norm, temp_scores, temp_attn_weights, temp_scale, temp_gate, temp_up, temp_swiglu, temp_mlp_out, const_zeros_large, const_zeros_small, const_neg_inf, seq_len, tile_rows, num_tiles, zero);
    
    clock_gettime(CLOCK_MONOTONIC, &end_time);
    double orch_time_ms = (end_time.tv_sec - start_time.tv_sec) * 1000.0 +
                          (end_time.tv_nsec - start_time.tv_nsec) / 1000000.0;
    // === END BENCHMARK ===
    
    int64_t tasks_submitted = rt->total_tasks_scheduled;
    
    if (benchmark_only) {
        // Benchmark mode: just output stats in parseable format
        double tasks_per_ms = tasks_submitted / orch_time_ms;
        printf("BENCHMARK: num_tiles=%d tasks=%lld time_ms=%.3f tasks_per_ms=%.2f\n",
               num_tiles, (long long)tasks_submitted, orch_time_ms, tasks_per_ms);
    } else {
        printf("  Submitted %lld tasks\n", (long long)tasks_submitted);
        printf("  Orchestration time: %.3f ms (%.2f tasks/ms)\n", 
               orch_time_ms, tasks_submitted / orch_time_ms);
        
        // Dump task graph before simulation
#ifdef PTO_TASK_DUMP
        pto_runtime_dump(rt, "llama_layer_dynamic_task_graph.txt");
#endif
        
        printf("\nPhase 2: Running cycle-accurate simulation...\n");
        
        // Run cycle-accurate simulation
        pto_simulate_all(rt);
        
        // Print cycle trace summary
        pto_trace_print_summary();
        
        // Save trace to JSON for visualization
        const char* trace_file = getenv("PTO_TRACE_OUTPUT");
        if (!trace_file) {
            trace_file = "trace.json";
        }
        pto_trace_write_json(trace_file);
        printf("Trace saved to: %s\n", trace_file);
        printf("  Open in Chrome: chrome://tracing and load the file\n");
    }
    
    // Shutdown and free resources
    pto_runtime_shutdown(rt);
    free(rt);
    cleanup_incore_simulator();
    
    // Free test data
    free(input);
    free(output);
    free(attn_norm_weights);
    free(wq);
    free(wk);
    free(wv);
    free(wo);
    free(cos_cache);
    free(sin_cache);
    free(mlp_norm_weights);
    free(w_gate);
    free(w_up);
    free(w_down);
    free(all_q_tiles);
    free(all_k_tiles);
    free(all_v_tiles);
    free(all_q_rope);
    free(all_k_rope);
    free(all_attn_out);
    free(all_m_vec);
    free(all_l_vec);
    free(all_hidden);
    free(temp_norm);
    free(temp_scores);
    free(temp_attn_weights);
    free(temp_scale);
    free(temp_gate);
    free(temp_up);
    free(temp_swiglu);
    free(temp_mlp_out);
    free(const_zeros_large);
    free(const_zeros_small);
    free(const_neg_inf);
    
    if (!benchmark_only) {
        printf("\n=== Simulation Complete ===\n");
    }
    return 0;
}
